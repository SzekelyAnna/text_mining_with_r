[["index.html", "Szövegbányászat és mesterséges intelligencia R-ben 1 Bevezetés", " Szövegbányászat és mesterséges intelligencia R-ben Sebk Miklós, Ring Orsolya 2021-02-18 15:30:05 1 Bevezetés Jelen kötet a Kvantitatív szövegelemzés és szövegbányászat a politikatudományban (LHarmattan, 2016) cím könyv folytatásaként és egyben kiegészítéseként a szövegbányászat és a mesterséges intelligencia társadalomtudományi alkalmazásának gyakorlatába nyújt bevezetést. A szövegek kvantitatív elemzése (quantitative text analysis  QTA) a nemzetközi társadalomtudomány egyik leggyorsabban fejld irányzata. A szövegek és más minségi adatok (filmek, képek) elemzése annyiban különbözik a mennyiségi (kvantitatív) adatokétól, hogy nyers formájukban még nem alkalmasak arra, hogy statisztikai, illetve ökonometriai elemzés alá vessük ket, s így további módszertani problémákat vetnek fel, melyek speciális tárgyalása szükséges. A tervezett kötetben bemutatott példák többsége a politikatudományhoz kapcsolódik, de más alkalmazási területekre is kitér. Míg az elz kötet az egyes kódolási eljárásokat, illetve ezek kutatás-módszertani elnyeit és hátrányait ismertette, itt a társadalomtudományi elemzésének során használható kvantitatív szövegelemzés legfontosabb gyakorlati feladatait vesszük sorra. A kézirat a magyar tankönyvpiacon az elsnek számít a tekintetben, hogy a társadalomtudományban használatos kvantitatív szövegelemzési eljárásokat részletesen, lépésrl-lépésre ismerteti, kezdve a megfelel korpusz kialakításához szükséges ismeretektl, a különböz szövegbányászati módszerek (szózsák, dokumentum-kifejezés mátrix, a névelem-felismerés, az osztályozás, illetve a csoportosítás feladataira), illetve az egyszerbb szövegösszehasonlítási-feladatok áttekintésén át, egészen a felügyelt és felügyelet nélküli gépi tanulásig, a politikatudományi vizsgálatok során leggyakrabban használatos R programnyelven készült programok segítségével. Az olvasó a két kötet együttes használatával olyan ismeretek birtokába kerül, melyek révén képes lesz alkalmazni a kvantitatív szövegelemzés és szövegbányászat legalapvetbb eljárásait saját kutatására. Deduktív vagy induktív felfedez logikája fényében dönthet az adatelemzés módjáról, és a felkínált menübl kiválaszthatja a kutatási tervéhez legjobban illeszked megoldásokat. A kötetet végigkísér konkrét példák segítségével pedig akár reprodukálhatja is ezen eljárásokat saját kutatásában. Mindezt a kötet függelékében helyet kapó R-scriptek részletes leírása is segíti majd. A kötet két f célcsoportjaként így a társadalomtudományi kutatói és felsoktatási közösséget határozzuk meg, valamint rögzítjük, hogy a kvantitatív szövegelemzés területén belül elsdlegesen a dokumentum- és tartalomelemzési módszertanhoz kapcsolódunk. A könyvben ugyancsak helyet kap a fontosabb fogalmak magyar és angol nyelv szószedete, valamint a további olvasásra ajánlott szakirodalom szerepeltetése. Az oktatásban való közvetlen alkalmazást segíthetik továbbá a fejezetek végén megadott vizsgakérdések, illetve a kötet honlapján (qta.tk.mta.hu) szerepl további információk: gyakorlófeladatok (megoldásokkal), az egyes feladatokra alkalmazható scriptek és kereskedelmi programok bemutatása, a témával kapcsolatos prezentációk és további ajánlott irodalmak. "],["a-kvantitatív-szövegelemzés-és-szövegbányászat-alapfogalmai.html", "2 A kvantitatív szövegelemzés és szövegbányászat alapfogalmai", " 2 A kvantitatív szövegelemzés és szövegbányászat alapfogalmai elso fejezet "],["az-adatkezelés-r-ben.html", "3 Az adatkezelés R-ben 3.1 Adatok importálása és exportálása 3.2 Adatok exportálása 3.3 A pipe operátor 3.4 Muveletek a date framekkel 3.5 Munka karakter vektorokkal4", " 3 Az adatkezelés R-ben 3.1 Adatok importálása és exportálása library(readr) Az adatok importálására az R alapfüggvénye mellett több package is megoldást kínál. Ezek közül a könyv írásakor a legnépszerbbek a readr és a rio csomagok. A karakter kódolással a legjobban a tapasztalataink szerint a readr csomag read_csv() megoldása bíkózik meg, ezért ezt fogjuk használni a .csv állományok beolvasására. Amennyiben kihasználjuk az RStudio projekt opcióját (lásd a Függelékben) akkor elegend csak az elérni kívánt adatok relativ elérési útját megadni (relative path). Ideális esetben az adataink egy csv fileban vannak (comma separated values), ahol az egyes értékeket vesszk (vagy egyéb speciális karakter) választják el. Ez esetben a read_delim() függvényt használjuk. A beolvasásnál egybl el is tároljuk az adatokat egy objektumban. A sep = opcióval tudjuk a szeparátor karaktert beállítani, mert elfordulhat hogy vessz helyett pontosvessz tagolja az adatainkat. df &lt;- read_csv(&quot;data/adatfile.csv&quot;) Az R képes linkrl letölteni fileokat, elég megadnunk egy mköd elérési útvonalat. placeholder link, cserelni majd mukodore df_online &lt;- read.csv(&quot;https://www.qta.tk.mta.hu/adatok/adatfile.csv&quot;) Az R package ökoszisztémája kellen változatos ahhoz, hogy gyakorlatilag bármilyen inputtal meg tudjon bírkózni. Az Excel fileokat a readxl csomagot használva tudjuk betölteni (a csomagok installálásával kapcsolatban lásd a Függeléket), a read_excel()-t használva. A leggyakoribb statisztikai programok formátumait pedig a haven csomag tudja kezelni (például Stata, Spss, SAS). A szintaxis itt is hasonló: read_stata, read_spss, read_sas. 3.1.1 Szöveges dokumentumok importálása A nagy mennyiség szöveges dokumentum (a legyakrabban elforduló kiterjesztések: .txt, .doc, .pdf, .json, .csv, .xml, .rtf, .odt) betöltésére a legalkalmasabb a readtext package. Az alábbi példa azt mutatja be, hogy hogyan tudunk beolvasni egy adott mappából az összes .txt kiterjesztés file-t, anélkül hogy bármilyen loop-ot kellene írnunk, vagy egyenként megadni a file-ok neveit. A * karakter az azt jelenti ebben a környezetben, hogy bármilyen fájl, ami .txt-re végzdik. Amennyiben a fájlok nevei tartalmaznak valamilyen meta adatot tartalmaznak, akkor ezt be tudjuk allítani a betöltés során. Ilyen meta adat lehet például egy parlamenti felszólalásnál a felszólaló neve és a beszéd ideje és párttagsága (például: kovacsjanos_1994_fkgp.txt). df_text &lt;- readtext( &quot;data/*.txt&quot;, docvarsfrom = &quot;filenames&quot;, dvsep = &quot;_&quot;, docvarnames = c(&quot;nev&quot;, &quot;ev&quot;, &quot;part&quot;) ) 3.2 Adatok exportálása Az adatainkat R-bl a write.csv()-vel exportálhatjuk a kívánt helyre, .csv formátumban. Az R rendelkezik saját, .Rds és .Rda kiterjesztés, tömörített fájlformátummal. Mivel ezeket csak az R-ben nyithatjuk meg, érdemes a köztes, hosszadalmas számítást igényl lépések elmentésére használni, a saveRDS() és a save() parancsokkal. Az openxlsx csomaggal .xls és .xlsx Excel formátumokba is tudunk exportálni, hogyha szükséges. 3.3 A pipe operátor Az úgynevezett pipe operátor alapjaiban határozta meg a modern R fejldését és a népszer package ökoszisztéma, a tidyverse, egyik alapköve. Úgy gondoljuk, hogy a tidyverse és a pipe egyszerbbé teszi elsajátítani az R használatát, ezért mi is erre helyezzük a hangsúlyt.1 Vizuálisan a pipe operátor így néz ki: %&gt;% és arra szolgál hogy a kódban több egymáshoz kapcsolódó mveletet egybefzznk.2 Technikailag a pipe a bal oldali elemet adja meg a jobb oldali függvény els argumentumának. A lenti példa ugyanazt a folyamatot írja le, az alap R (base R) illetve a pipe használatával.3 Miközben a kódot olvassuk érdemes a pipe-ot és aztán-nak fordítani. reggeli(oltozkodes(felkeles(ebredes(en, idopont = &quot;8:00&quot;), oldal = &quot;jobb&quot;), nadrag = TRUE, ing = TRUE)) en %&gt;% ebredes(idopont = &quot;8:00&quot;) %&gt;% felkeles(oldal = &quot;jobb&quot;) %&gt;% oltozkodes(nadrag = TRUE, ing = TRUE) %&gt;% reggeli() A fenti példa is jól mutatja, hogy a pipe a bal oldali elemet fogja a jobb oldali függvény els elemének berakni. A fejezet további részeiben még bven fogunk gyakorlati példát találni a használatára. A fejezetben bemutatott példák az alkalmazásoknak csak egy relatíve szk körét mutatják be, ezért érdemes átolvasni a csomagokhoz tartozó dokumentációt, illetve ha van, akkor a mködést demonstráló bemutató oldalakat is. 3.4 Muveletek a date framekkel A data frame az egyik leghasznosabb és leggyakrabban használt adat tárolási mód az R-ben (a részletesebb leírás a Függelékben található) és ebben az alfejezetben azt mutatjuk be a dplyr és gapminder csomagok segíségével, hogy hogyan lehet hatékonyan dolgozni velük. A dplyr az egyik legnépszerbb R csomag, a tidyverse része. A gapminder csomag pedig a példa adatbázisunkat tartalmazza, amiben a világ országainak különböz gazdasági és társadalmi mutatói vannak. library(dplyr) library(gapminder) 3.4.1 Megfigyelések szrése: filter() A sorok (megfigyelések) szréséhez a dplyr csomag filter() parancsát használva lehetségünk van arra hogy egy vagy több kritérium alapján szkítsük az adatbázisunkat. A lenti példában azokat megfigyeléseket tartjuk meg, ahol az év 1962 és a várható élettartam nagyobb mint 72 év. gapminder %&gt;% filter(year == 1962, lifeExp &gt; 72) #&gt; # A tibble: 5 x 6 #&gt; country continent year lifeExp pop gdpPercap #&gt; &lt;fct&gt; &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; #&gt; 1 Denmark Europe 1962 72.4 4646899 13583. #&gt; 2 Iceland Europe 1962 73.7 182053 10350. #&gt; 3 Netherlands Europe 1962 73.2 11805689 12791. #&gt; 4 Norway Europe 1962 73.5 3638919 13450. #&gt; 5 Sweden Europe 1962 73.4 7561588 12329. De ugyanígy leválogathatjuk a data frame-bl az adatokat akkor is hogyha egy karakter változó alapján szeretnénk szrni. gapminder %&gt;% filter(country == &quot;Sweden&quot;, year &gt; 1990) #&gt; # A tibble: 4 x 6 #&gt; country continent year lifeExp pop gdpPercap #&gt; &lt;fct&gt; &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; #&gt; 1 Sweden Europe 1992 78.2 8718867 23880. #&gt; 2 Sweden Europe 1997 79.4 8897619 25267. #&gt; 3 Sweden Europe 2002 80.0 8954175 29342. #&gt; 4 Sweden Europe 2007 80.9 9031088 33860. Itt tehát a data frame azon sorait szeretnénk látni, ahol az ország megegyezik a Sweden\" karakterlánccal az év pedig nagyobb, mint 1990. 3.4.2 Változók kiválogatása: select() A select() függvény segítségével válogathatunk oszlopokat a data frame-bl. A változók kiválasztására több megoldás is van. A dplyr csomag tartalmaz apróbb kisegít függvényeket, amik megkönnyítik a nagy adatbázisok esetén a változók kiválogatását a nevük alapján. Ezek a függvények a contains(), starts_with(), ends_with(), matches() és beszédesen arra szolgálnak hogy bizonyos nev változókat ne kelljen egyenként felsorolni. A select()-en belüli változó sorrend egyben az eredmény data frame változó sorrendjet is megadja. A negatív kiválasztás is lehetséges, ebben az esetben egy - kell tennünk a nemkívánt változó(k) elé (pl.: select(df, year, country, -continent). gapminder %&gt;% select(contains(&quot;ea&quot;), starts_with(&quot;co&quot;), pop) #&gt; # A tibble: 1,704 x 4 #&gt; year country continent pop #&gt; &lt;int&gt; &lt;fct&gt; &lt;fct&gt; &lt;int&gt; #&gt; 1 1952 Afghanistan Asia 8425333 #&gt; 2 1957 Afghanistan Asia 9240934 #&gt; 3 1962 Afghanistan Asia 10267083 #&gt; 4 1967 Afghanistan Asia 11537966 #&gt; 5 1972 Afghanistan Asia 13079460 #&gt; 6 1977 Afghanistan Asia 14880372 #&gt; 7 1982 Afghanistan Asia 12881816 #&gt; 8 1987 Afghanistan Asia 13867957 #&gt; 9 1992 Afghanistan Asia 16317921 #&gt; 10 1997 Afghanistan Asia 22227415 #&gt; # ... with 1,694 more rows 3.4.3 Új változók létrehozása: mutate() Az elemzési munkafolyamat elkerülhetetlen része hogy új változókat hozzunk létre, vagy a meglévket módosítsuk. Ezt a mutate()-el tehetjuk meg, ahol a szintaxis a következ: mutate(data frame, uj valtozo = ertekek). Példaként kiszámoljuk a Svéd GDP-t (milliárd dollárban) 1992-tl kezdve. A mutate() alkalmazásával részletesebben is foglalkozunk a szövegek elkészítésével foglalkozó fejezetben. gapminder %&gt;% filter(country == &quot;Sweden&quot;, year &gt;= 1992) %&gt;% mutate(gdp = (gdpPercap * pop) / 10^9) #&gt; # A tibble: 4 x 7 #&gt; country continent year lifeExp pop gdpPercap gdp #&gt; &lt;fct&gt; &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 Sweden Europe 1992 78.2 8718867 23880. 208. #&gt; 2 Sweden Europe 1997 79.4 8897619 25267. 225. #&gt; 3 Sweden Europe 2002 80.0 8954175 29342. 263. #&gt; 4 Sweden Europe 2007 80.9 9031088 33860. 306. 3.4.4 Csoportonkénti statisztikák: group_by() és summarize() Az adataink részletesebb és alaposabb megismerésében segítenek a különböz szint leíró statisztikai adatok. A szintek megadására a group_by() használható, a csoportokon belüli számításokhoz pedig a summarize(). A lenti példa azt illusztrálja, hogyha kontinensenként csoportosítjuk a gapminder data framet, akkor a summarise() használatával megkaphatjuk a megfigyelések számát, illetve az átlagos per capita GDP-t. A summarise() a mutate() közeli rokona, hasonló szintaxissal és logikával használható. Ezt a függvény párost fogjuk majd használni a szöveges adataink leíró statisztikáinál is a 4. fejezetben. gapminder %&gt;% group_by(continent) %&gt;% summarise(megfigyelesek = n(), atlag_gdp = mean(gdpPercap)) #&gt; # A tibble: 5 x 3 #&gt; continent megfigyelesek atlag_gdp #&gt; &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; #&gt; 1 Africa 624 2194. #&gt; 2 Americas 300 7136. #&gt; 3 Asia 396 7902. #&gt; 4 Europe 360 14469. #&gt; 5 Oceania 24 18622. 3.5 Munka karakter vektorokkal4 A szöveges adatokkal (karakter stringekkel) való munka elkerülhetetlen velejárója hogy a felesleges szövegelemeket, karaktereket el kell távolítanunk ahhoz hogy az elemzésünk hatásfoka javuljon (errl részletesebben a 3. fejezetben lesz szó). Erre a célra a stringr csomagot fogjuk használni, kombinálva a korábban bemutatott mutate()-el. A stringr függvények az str_ eltaggal kezddnek és eléggé beszédes nevekkel rendelkeznek. Egy gyakran elforduló probléma, hogy extra szóközök maradnak a szövegben, vagy bizonyos szavakról, karakterkombinációkról tudjuk hogy nem kellenek az elemzésünkhoz. Ebben az esetben egy vagy több regular expression (regex) használatával tudjuk pontosan kijelölni hogy a karakter sornak melyik részét akarjuk módosítani. A legegyszerbb formája a regexeknek, hogyha pontosan tudjuk milyen szöveget akarunk megtalálni. A kísérletezésre az str_view()-t használjuk, ami megjeleníti hogy a megadott regex mintánk pontosan mit jelöl. library(stringr) szoveg &lt;- c(&quot;gitar&quot;, &quot;ukulele&quot;, &quot;nagybogo&quot;) str_view(szoveg, pattern = &quot;ar&quot;) Az anchor-okkal azt lehet megadni, hogy a karakter string elején vagy végén szeretnénk egyezést találni. A string eleji anchor a ^, a string végi pedig a $. str_view(&quot;Dr. Doktor Dr.&quot;, pattern = &quot;^Dr.&quot;) str_view(&quot;Dr. Doktor Dr.&quot;, pattern = &quot;Dr.$&quot;) Egy másik jellemz probléma, hogy olyan speciális karaktert akarunk leírni a regex kifejezésünkkel, ami amúgy a regex szintaxisban használt. Ilyen eset például a ., ami mint írásjel sokszor csak zaj, ám a regex kotextusban a bármilyen karakter megfelelje. str_view(&quot;Dr. Doktor Dr.&quot;, pattern = &quot;.k.&quot;) Ahhoz hogy magát az írásjelet jelöljük, a \\\\ -t kell elé rakni. str_view(&quot;Dr. Doktor Dr.&quot;, pattern = &quot;\\\\.&quot;) Néhány hasznos regex kifejezés: [:digit:] - számok (123) [:alpha:] - betk (abc ABC) [:lower:] - kisbetk (abc) [:upper:] - nagybetk (ABC) [:alnum:] - betk és számok (123 abc ABC) [:punct:] - központozás (.!?\\(){}) [:graph:] - betk, számok és központozás (123 abc ABC .!?\\(){}) [:space:] - szóköz ( ) [:blank:] - szóköz és tabulálás [:cntrl:] - kontrol karakterek (\\n, \\r, stb.) * - bármi A tidyverse megközelítés miatt a kötetben szerepl R kód követi a The tidyverse style guide dokumentációt (https://style.tidyverse.org/) Az RStudio-ban a pipe operátor billenty kombinációja a Ctrl + Shift + M Köszönjük Andrew Heissnek a kitn példát. A könyv terjedelme miatt ezt a témát itt csak bemutatni tudjuk, de minden részletre kiterjeden nem tudunk elmélyülni benne. Kíváló online anyagok találhatóak az RStudio GitHub tárhelyén (https://github.com/rstudio/cheatsheets/raw/master/strings.pdf), illetve Wickham and Grolemund (2016) 14. fejezetében. "],["leíró-statisztika-szózsák-és-szóeloszlások.html", "4 Leíró statisztika: szózsák és szóeloszlások", " 4 Leíró statisztika: szózsák és szóeloszlások negyedik fejezet "],["a-szövegek-reprezentálása-a-vektortérben.html", "5 A szövegek reprezentálása a vektortérben", " 5 A szövegek reprezentálása a vektortérben otodik fejezet "],["a-korpuszépítés-problémái-és-a-szövegel-készítés.html", "6 A korpuszépítés problémái és a szövegelkészítés", " 6 A korpuszépítés problémái és a szövegelkészítés hatodik fejezet "],["szótáralapú-elemzések-érzelem-elemzés.html", "7 Szótáralapú elemzések, érzelem-elemzés 7.1 Szótárak az R-ben 7.2 Magyar Nemzet cikkek 7.3 MNB sajtóközlemények", " 7 Szótáralapú elemzések, érzelem-elemzés A szótár alapú szentiment elemzés egy egyszer ötleten alapul. Hogyha tudjuk hogy egyes szavak milyen érzelmeket, érzéseket, információt hordoznak, akkor minél gyakoribb egy-egy érzelem kategóriához tartozó szó, akkor a szentiment annél inkább jellemz lesz a dokumentumra amit vizsgálunk. Természetesen itt is jó pár dolognak kell teljesülnie ahhoz hogy az elemzésünk eredménye megbízható legyen. Mivel a szótár alapú elemzés az adott szentiment kategórián belüli kulcsszavak gyakoriságán alapul, ezért van aki nem tekinti statisztikai elemzésnek (lásd például Young and Soroka (2012)). A tágabb kvantitatív szövegelemzési kontextusban az osztályozáson (classification) belül a felügyelt módszerekhez hasonlóan itt is ismert kategóriákkal dolgozunk (pl.: egy kulcsszó az öröm kategóriába tartozik), csak egyszerbb módszertannal (Grimmer and Stewart 2013). A kulcsszavakra építés miatt a módszer a kvalitatív és kvantitatív kutatási vonalak találkozásának is tekinthet, hiszen egy-egy szónak az érzelmi töltete nem mindig ítélhet meg objektíven. Mint minden módszer esetében, amirl ebben a tankönyvben szó van, itt is kiemelten fontos hogy ellenrízzük hogy a használt szótár kategóriák és kulcsszavak fedik-e a valóságot. Más szavakkal: validate, validate, validate. A módszer elnyei: Tökéletesen megbízható: nincsen probabilisztikus eleme a számításoknak, mint például a Support Vector alapú osztályozásnál, illetve az emberi szövegkódolásnál elforduló problémákat is elkerüljük így. Képesek vagyunk vele mérni a szöveg látens dimenzióit. Széles körben alkalmazható, egyszeren számolható. A politikatudományon és számítogépes nyelvtudományokon belül nagyon sok kész szótár elérhet, amik különböz módszerekkel készültek és különböz területet fednek le (pl.: populizmus, pártprogramok policy tartalma, érzelmek, gazdasági tartalom.)5 Relatíve könnyen adaptálható egyik nyelvi környezetbl másikba. A módszer lehetéges hátrányai: A szótár hatékonysága és validitása azon múlik hogy mennyire egyezik a szótár és a viszgálni kívánt dokumentum területe. Például jellemz hiba, hogy gazdasági bizonytalanságot szeretnék tzsdei jelentések alapján vizsgálni a kutatók egy általános szentimet szótár használatával. A terület-specifikus szótár építése egy kvalitatív folyamat (lsd. a labjegyzetben), éppen ezért gyakran id és emberi erforrás igényes. A szózsák alapú elemzéseknél a kontextus elvész (ez gyakran igaz a bigram és trigramok használatánál is) a kulcsszavak esetében. Erre egy triviális példa a tagadás a mondatban: nem vagyok boldog esetén egy általános szentiment szótár a tagadás miatt félreosztályozná a mondat érzelmi töltését. Az elemzés sikere több faktortól is függ. Fontos hogy a korpuszban lév dokumentumokat körültekinten tisztítsuk meg az elemzés elején (lásd a 4. fejezetet a szövegelkészítésrl). A következ lépésben meg kell bizonyosodnunk arról, hogy a kiválasztott szentiment szótár alkalmazható a korpuszunkra. Amennyiben nem találunk alkalmas szótárat, akkor a saját szótár validálására kell figyelni. A negyedik fejezetben leírtak itt is érvényesek, érdemes a dokumentum-kifejezés mátrixot súlyozni valamilyen módon. 7.1 Szótárak az R-ben A szótár alapú elemzéshez a quanteda csomagot fogjuk használni, illetve a 3. fejezetben már megismert readr, stringr, dplyr tidyverse csomagokat.6 library(readr) library(stringr) library(dplyr) library(quanteda) Mieltt a két esettanulmányt bemutatnánk, vizsgáljuk meg hogy hogyan néz ki egy szentiment szótár az R-ben. A szótárt kézzel úgy tudjuk létrehozni, hogy egy listán belül létrehozzuk karaktervektorként a kategóriákat és a kulcsszavakat és ezt a listát a quanteda dictionary függvényével eltároljuk. szentiment_szotar &lt;- dictionary(list( pozitiv = c(&quot;jó&quot;, &quot;boldog&quot;, &quot;öröm&quot;), negativ = c(&quot;rossz&quot;, &quot;szomorú&quot;, &quot;lehangoló&quot;) )) szentiment_szotar #&gt; Dictionary object with 2 key entries. #&gt; - [pozitiv]: #&gt; - jó, boldog, öröm #&gt; - [negativ]: #&gt; - rossz, szomorú, lehangoló A quanteda, quanteda.corpora és tidytext R csomagok több széles körben használt szentiment szótárat tartalmaznak, így nem kell kézzel replikálni minden egyes szótárat amit használni szeretnénk. A szentiment elemzési munkafolyamat amit a részfejezetben bemutatunk a következ lépésekbl áll: dokumentumok betöltése szöveg elkészítése a korpusz létrehozása dokumentum-kifejezés mátrix szótár betöltése a dokumentum-kifejezés mátrix szrése a szótárban lév kulcsszavakkal az eredmény vizualizálása, további felhasználása A fejezetben két különböz korpuszt fogunk elemezni: a 2006-os Magyar Nemzet címlapjainak egy 252 cikkbl álló mintájának szentimentjét vizsgáljuk egy magyar szentiment szótárral. A második korpusz a Magyar Nemzeti Bank angol nyelv sajtóközleményeibl áll, amin bemutatjuk egy széles körben használt gazdasági szótár használatát. 7.2 Magyar Nemzet cikkek mn_minta &lt;- read_csv(&quot;data/magyar_nemzet_small.csv&quot;) summary(mn_minta) #&gt; doc_id text doc_date #&gt; Min. : 1.0 Length:2834 Min. :2006-01-02 #&gt; 1st Qu.: 709.2 Class :character 1st Qu.:2006-03-29 #&gt; Median :1417.5 Mode :character Median :2006-06-28 #&gt; Mean :1417.5 Mean :2006-06-28 #&gt; 3rd Qu.:2125.8 3rd Qu.:2006-09-26 #&gt; Max. :2834.0 Max. :2006-12-29 A read_csv() segítségével beolvassuk a Magyar Nemzet adatbázis egy kisebb részét, ami az esetünkben a 2006-os cimlapokon szerepl hírek . A summary(), ahogy a neve is mutatja, egy gyors áttekinténtést nyújt a betöltött adatbázisról. Látjuk, hogy 2834 sorbol (megfigyelés) és 3 oszlopból (változó) áll. Az els ránézésre látszik hogy a text változónk tartalmazza a szövegeket, és hogy tisztításra szorulnak. Az els szöveget megnézve látjuk, hogy a standard elkészítési lépések mellett a sortörést (\\n) is ki kell törölnünk. mn_minta$text[1] #&gt; [1] &quot;Hat fovárosi képviselo öt percnél is kevesebbet beszélt egy év alatt a közgyulésben.\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n&quot; Habár a quanteda is lehetséget ad néhány elékészít lépésre, érdemes ezt olyan céleszközzel tenni ami nagyobb rugalmasságot ad a kezünkbe. Mi erre a célra a stringr csomagot használjuk. Els lépésben kitöröljük a sortöréseket (\\n), a központozást, számokat, kisbetsítünk minden szót. Elfordulhat hogy (számunkra nehezen látható) extra szóközök maradnak a szövegben. Ezeket az str_squish()-el tüntetjük el. A szöveg eleji és végi extra szóközöket (ún. leading vagy trailing white space) az str_trim() vágja le. mn_tiszta &lt;- mn_minta %&gt;% mutate( text = str_remove_all(string = text, pattern = &quot;\\n&quot;), text = str_remove_all(string = text, pattern = &quot;[:punct:]&quot;), text = str_remove_all(string = text, pattern = &quot;[:digit:]&quot;), text = str_to_lower(text), text = str_trim(text), text = str_squish(text) ) A szöveg sokkal jobban néz ki, habár észrevehetjük hogy maradhattak benne problémás részek, fleg a sortörés miatt, ami sajnos hol egyes szavak közepén van (a jobbik eset), vagy pedig pont szóhatáron, ez esetben a két szó sajnos összevonódik. Az egyszerség kedvéért feltételezzük hogy ez kellen ritkán fordul el ahhoz hogy ne befolyásolja az elemzésünk eredményét. mn_tiszta$text[1] #&gt; [1] &quot;hat fovárosi képviselo öt percnél is kevesebbet beszélt egy év alatt a közgyulésben&quot; Miután kész a tiszta(bb) szövegünk, kreálunk egy korpuszt a quanteda corpus() fuggvenyevel. A létrehozott corpus objektum a szöveg mellett egyéb dokumentum meta adatokat is tud tárolni (dátum, író, hely, stb.) Ezeket mi is hozzáadhatjuk (erre majd látunk példát nemsokára) illetve amikor létrehozzuk a korpuszt a data frame-ünkbl, akkor autómatikusan meta adatokként tárolódnak az változóink. Jelen esetben az egyetlen dokument változónk az a dátum lesz a szöveg mellett. A korpusz dokumentum változóihoz a docvars() segíségével tudunk hozzáférni. mn_corpus &lt;- corpus(mn_tiszta) head(docvars(mn_corpus), 5) #&gt; doc_date #&gt; 1 2006-01-02 #&gt; 2 2006-01-02 #&gt; 3 2006-01-02 #&gt; 4 2006-01-02 #&gt; 5 2006-01-02 A következ lépés a dokument-kifejezés mátrix létrehozása a dfm() függvénnyel (ami a document-feature matrix rövidítése). Elszr tokenekre bontjuk a szövegeket a tokens()-el, és aztán ezt a tokenizált szózsákot kapja meg a dfm inputnak. A sornak a végén a létrehozott mátrixunkat TF-IDF módszerrel súlyozzuk a dfm_tfidf() használatával. mn_dfm &lt;- mn_corpus %&gt;% tokens(what = &quot;word&quot;) %&gt;% dfm() %&gt;% dfm_tfidf() A cikkek szentimentjét egy magyar szótárral fogjuk becsülni, amit a Társadalomtudmányi Kutatóközpont CSS-RECENS és a POLTEXTLab kutatói készítették.7 Két dimenziót tarlamaz (pozitív és negatív), 2299 pozitív és 2588 negatív kulcsszóval. Ez nem számít kirívóan nagynak a szótárak között, mivel az adott kategóriák minél teljesebb lefedése a cél. Azt is látjuk, hogy a kulcsszavak egyszavas tokenek (szóval nem érdemes bigramokat és trigramokat készítenünk a tokenizálás során), illetve nem szótövek (így szótöveznünk sem kell). poltext_szotar #&gt; Dictionary object with 2 key entries. #&gt; - [positive]: #&gt; - abszolút, ad, adaptív, adekvát, adócsökkentés, adókedvezmény, adomány, adományoz, adóreform, adottság, adottságú, áfacsökkentés, agilis, agytröszt, áhított, ajándék, ajándékoz, ajánl, ajánlott, akadálytalan [ ... and 2,279 more ] #&gt; - [negative]: #&gt; - aberrált, abnormális, abnormalitás, abszurd, abszurditás, ádáz, adócsalás, adócsaló, adós, adósság, áfacsalás, áfacsaló, affér, aggasztó, aggodalom, aggódik, aggódás, agresszió, agresszíven, agresszivitás [ ... and 2,568 more ] Az egyes dokumentumok szentimentjét a dfm_lookup() becsüli, ahol az elz lépésben létrehozott súlyozott dfm az input és a magyar szentimentszótár a dictionary. Egy gyors pillantás az eredményre és látjuk hogy minden dokumentumhoz készült egy pozitív és egy negatív értéket. A TF-IDF súlyozás miatt nem látunk egész számokat (a súlyozás nélkül a sima szófrekvenciát kapnánk). mn_szentiment &lt;- dfm_lookup(mn_dfm, dictionary = poltext_szotar) head(mn_szentiment, 5) #&gt; Document-feature matrix of: 5 documents, 2 features (40.0% sparse) and 1 docvar. #&gt; features #&gt; docs positive negative #&gt; 1 0 0 #&gt; 2 0.8375026 12.497973 #&gt; 3 0 0 #&gt; 4 21.1044299 6.449036 #&gt; 5 11.0358129 8.131890 Ahhoz hogy fel tudjuk használni a kapott eredményt, érdemes dokumentumváltozóként eltárolni a korpuszban. Ezt a fent már használt docvars() segítségével tudjuk megtenni, ahol a második argumentumkét az új változó nevét adjuk meg stringként. docvars(mn_corpus, &quot;pos&quot;) &lt;- as.numeric(mn_szentiment[, 1]) docvars(mn_corpus, &quot;neg&quot;) &lt;- as.numeric(mn_szentiment[, 2]) head(docvars(mn_corpus), 5) #&gt; doc_date pos neg #&gt; 1 2006-01-02 0.0000000 0.000000 #&gt; 2 2006-01-02 0.8375026 12.497973 #&gt; 3 2006-01-02 0.0000000 0.000000 #&gt; 4 2006-01-02 21.1044299 6.449036 #&gt; 5 2006-01-02 11.0358129 8.131890 Végül a kapott korpuszt a kiszámolt szentiment értékekkel a quanteda-ban lév convert() fügvénnyel data frame-é alakítjuk. A convert függvény dokumentációját érdemes elolvasni, mert ennek segítségével tudjuk a quanteda-ban elkeszült objektumainkat átalakítani úgy, hogy azt más csomagok is tudják használni. mn_df &lt;- convert(mn_corpus, to = &quot;data.frame&quot;) summary(mn_df) #&gt; doc_id text doc_date pos #&gt; Length:2834 Length:2834 Min. :2006-01-02 Min. : 0.000 #&gt; Class :character Class :character 1st Qu.:2006-03-29 1st Qu.: 0.000 #&gt; Mode :character Mode :character Median :2006-06-28 Median : 2.373 #&gt; Mean :2006-06-28 Mean : 4.074 #&gt; 3rd Qu.:2006-09-26 3rd Qu.: 6.280 #&gt; Max. :2006-12-29 Max. :35.648 #&gt; neg #&gt; Min. : 0.000 #&gt; 1st Qu.: 0.000 #&gt; Median : 2.037 #&gt; Mean : 3.528 #&gt; 3rd Qu.: 5.348 #&gt; Max. :39.096 Mieltt vizualizálnánk az eredményt érdemes a napi szintre aggregálni a szentimentet és egy nettó értéket kalkulálni.8 mn_df &lt;- mn_df %&gt;% group_by(doc_date) %&gt;% summarise( daily_pos = sum(pos), daily_neg = sum(neg), net_daily = daily_pos - daily_neg ) A plot alapján egyértelm trendet nem lehet megállapítani és még a 2006-os év végi turbulens belpolitikai események sem feltétlenül jelennek meg markánsan. Ennek az oka abban is kereshet, hogy egy napilap címlapját ritkán dominálja teljes egészében a belpolitika és így a negatív és pozitív szentimentek kioltják egymást. Természetesen messzemen következtetéseket egy ábra alapján nem érdemes levonni, de az elemzésünk azt mutatha hogy a nyári hónapok alatt kevesebb volt az igazán negatív címlap, ellenben az év eleje és vége tartalmazta a minta alsó széls értékeit. library(ggplot2) ggplot(mn_df, aes(doc_date, net_daily)) + geom_line() + labs( title = &quot;Magyar Nemzet címlap szentimentje&quot;, subtitle = &quot;A szentiment érték a pozitív és negatív szentiment pontszámok különbsége a teljes mintára.&quot;, y = &quot;Szentiment&quot;, x = NULL, caption = &quot;Adatforrás: https://cap.tk.hu/&quot; ) 7.3 MNB sajtóközlemények A második esettanulmányban a kotextuális szótár elemzést mutatjuk be egy angol nyelv korpusz és specializált szótár segítségével. A korpusz az MNB kamatdöntéseit kísér nemzetközi sajtóközleményei és a szótár pedig a Loughran and McDonald (2011) pénzügyi szentimentszótár.9 A szótár a quanteda.dictionaries csomag részeként elérhet, illetve a tankönyv honlapján is megtalálható. penzugy_szentiment #&gt; Dictionary object with 9 key entries. #&gt; - [NEGATIVE]: #&gt; - abandon, abandoned, abandoning, abandonment, abandonments, abandons, abdicated, abdicates, abdicating, abdication, abdications, aberrant, aberration, aberrational, aberrations, abetting, abnormal, abnormalities, abnormality, abnormally [ ... and 2,335 more ] #&gt; - [POSITIVE]: #&gt; - able, abundance, abundant, acclaimed, accomplish, accomplished, accomplishes, accomplishing, accomplishment, accomplishments, achieve, achieved, achievement, achievements, achieves, achieving, adequately, advancement, advancements, advances [ ... and 334 more ] #&gt; - [UNCERTAINTY]: #&gt; - abeyance, abeyances, almost, alteration, alterations, ambiguities, ambiguity, ambiguous, anomalies, anomalous, anomalously, anomaly, anticipate, anticipated, anticipates, anticipating, anticipation, anticipations, apparent, apparently [ ... and 277 more ] #&gt; - [LITIGIOUS]: #&gt; - abovementioned, abrogate, abrogated, abrogates, abrogating, abrogation, abrogations, absolve, absolved, absolves, absolving, accession, accessions, acquirees, acquirors, acquit, acquits, acquittal, acquittals, acquittance [ ... and 883 more ] #&gt; - [CONSTRAINING]: #&gt; - abide, abiding, bound, bounded, commit, commitment, commitments, commits, committed, committing, compel, compelled, compelling, compels, comply, compulsion, compulsory, confine, confined, confinement [ ... and 164 more ] #&gt; - [SUPERFLUOUS]: #&gt; - aegis, amorphous, anticipatory, appertaining, assimilate, assimilating, assimilation, bifurcated, bifurcation, cessions, cognizable, concomitant, correlative, deconsolidation, delineation, demonstrable, demonstrably, derecognized, derecognizes, derivatively [ ... and 36 more ] #&gt; [ reached max_nkey ... 3 more keys ] A szentiment szótár 9 kategóriából áll. A legtöbb kulcsszó a negatív dimenzióhoz van (2355). A munkamenet hasonló a Magyar Nemzetes példához: adat betöltés szövegtisztítás korpusz tokenek kulcs kontextuális tokenek szrése dfm elállítás és szentiment számítás az eredmény vizualizálása, további felhasználása mnb_pr &lt;- read_csv(&quot;data/mnb_pr_corpus.csv&quot;) summary(mnb_pr) #&gt; date text id year #&gt; Min. :2005-01-24 Length:180 Min. : 1.00 Min. :2005 #&gt; 1st Qu.:2008-10-14 Class :character 1st Qu.: 45.75 1st Qu.:2008 #&gt; Median :2012-07-10 Mode :character Median : 90.50 Median :2012 #&gt; Mean :2012-07-08 Mean : 90.50 Mean :2012 #&gt; 3rd Qu.:2016-03-30 3rd Qu.:135.25 3rd Qu.:2016 #&gt; Max. :2019-12-17 Max. :180.00 Max. :2019 Az adatbázisunk 180 megfigyelésbl és 4 változóbol áll. Az egyetlen lényeges dokumentum meta adat itt is a szövegek megjelenési ideje. A szövegeket ugyanazokkal a standard eszközökkel kezeljük mint a Magyar Nemzet esetében. Érdemes minden esetben ellenrízni, hogy az R kód amit használunk az tényleg azt csinálja-e mint amit szeretnénk hogy csináljon. Ez hatványozottan igaz abban az esetben, amikor szövegekkel és regular expressionökkel dolgozunk. mnb_tiszta &lt;- mnb_pr %&gt;% mutate( text = str_remove_all(string = text, pattern = &quot;[:cntrl:]&quot;), text = str_remove_all(string = text, pattern = &quot;[:punct:]&quot;), text = str_remove_all(string = text, pattern = &quot;[:digit:]&quot;), text = str_to_lower(text), text = str_trim(text), text = str_squish(text) ) Miután rendelkezésre állnak a tiszta dokumentumaink, egy karaktervektorba gyüjtjuk azokat a kulcsszavakat amelyek környékén szeretnénk megfigyelni a szentiment alakulását. A példa kedvéért mi az unemp*, growth, gdp, inflation* szótöveket és szavakat választottuk. A tokens_keep() megtartja a kulcsszavainkat és egy általunk megadott +/- n tokenes környezetüket (jelen esetben 10). A szentiment elemzést pedig már ezen a jóval kisebb mátrixon fogjuk lefuttatni. A phrase() segítségével több szóból álló kifejezéséket is vizsgálhatunk. Ilyen szókapcsolat például az Európai Unió is, ahol lényeges hogy egyben kezeljük a két szót. mnb_corpus &lt;- corpus(mnb_tiszta) gazdasag &lt;- c(&quot;unemp*&quot;, &quot;growth&quot;, &quot;gdp&quot;, &quot;inflation*&quot;, &quot;inflation expectation*&quot;) mnb_token &lt;- tokens(mnb_corpus) %&gt;% tokens_keep(pattern = phrase(gazdasag), window = 10) A szentimentet most is egy súlyozott dfm-bl számoljuk. A kész eredményt hozzáadjuk a korpuszhoz majd data framet hozunk létre belle. A 9 kategóriából 5-öt adunk választunk csak ki, amelyeknek jegybanki környezetben értelmezhet tartalma van. mnb_szentiment &lt;- tokens_lookup(mnb_token, dictionary = penzugy_szentiment) %&gt;% dfm() %&gt;% dfm_tfidf() docvars(mnb_corpus, &quot;negative&quot;) &lt;- as.numeric(mnb_szentiment[, &quot;negative&quot;]) docvars(mnb_corpus, &quot;positive&quot;) &lt;- as.numeric(mnb_szentiment[, &quot;positive&quot;]) docvars(mnb_corpus, &quot;uncertainty&quot;) &lt;- as.numeric(mnb_szentiment[, &quot;uncertainty&quot;]) docvars(mnb_corpus, &quot;constraining&quot;) &lt;- as.numeric(mnb_szentiment[, &quot;constraining&quot;]) docvars(mnb_corpus, &quot;superfluous&quot;) &lt;- as.numeric(mnb_szentiment[, &quot;superfluous&quot;]) mnb_df &lt;- convert(mnb_corpus, to = &quot;data.frame&quot;) A célunk hogy szentiment kategóriánkénti bontásban mutassuk be az elemzésünk eredményét, de eltte egy kicsit alakítani kell a data frame-n, hogy a második fejezetben is tárgyalt tidy formára hozzuk. A különböz szentiment értékeket tartalmazó oszlopokat fogjuk átrendezni úgy hogy kreálunk egy sent_type változót ahol a kategória nevet fogjuk eltárolni és egy sent_score változót, ahol a szentiment értéket. Ehhez a tidyr-ben található pivot_longer() -t használjuk. mnb_df &lt;- mnb_df %&gt;% pivot_longer( cols = negative:superfluous, names_to = &quot;sent_type&quot;, values_to = &quot;sent_score&quot; ) Az átalakítás után már könnyedén tudjuk kategóriákra bontva megjeleníteni az MNB közlemények különböz látens dimenzióit. Fontos emlékezni arra, hogy ez az eredmény a kulcsszavaink +/- 10 tokenes környezetében lév szavak szentimentjét mérik. Ami érdekes eredmény, hogy a felesleges töltelék szövegek (superflous kategória) szinte soha nem fordulnak el a kulcsszavaink körül. A többi érték is nagyjából megfelel a várakozásainknak, habár a 2008-as gazdasági válság nem tnik kiugró pontnak. Azonban a 2010 utáni európai válság már láthatóan megjelnik az idsorainkban. A szótár amit használtunk az alapveten az Egyesült Államokban a tzsdén kereskedett cégek publikus beszámolóiból készült így elképzelhet, hogy egyes jegybanki környezetben sokat használt kifejezés nincs benne. A validálása a kapott eredményeknek ezért is nagyon fontos, illetve érdemes azzal is tisztában lenni hogy a szótáras módszer nem tökéletes (ahogy az emberi vagy más gépi kódolás sem). ggplot(mnb_df, aes(date, sent_score)) + geom_line() + labs( title = &quot;Magyar Nemzeti Bank közleményeinek szentimentje&quot;, y = &quot;Szentiment&quot;, x = NULL ) + facet_wrap(~sent_type, ncol = 2) A lehetséges, területspecifikus szótáralkotási módszerekrl részletesebben ezekben a cikkekben lehet olvasni: Laver and Garry (2000); Young and Soroka (2012); Loughran and McDonald (2011); Máté, Sebk, and Barczikay (2021) A szentiment elemzéshez gyakran használt csomag még a tidytext. Az online is szabadon elérhet Silge and Robinson (2017) 2. fejezetében részletesen is bemutatják a szerzk a tidytext munkafolyamatot (https://www.tidytextmining.com/sentiment.html). A szótár elérhet a könyv online verziójának a GitHub repozitorijából. (LINK) A csoportosított adatokkal való munka bvebb bemutatását lsd. a Függelékben A témával részletesebben is foglalkoztunk a Máté, Sebk, and Barczikay (2021) tanulmányban, ahol egy saját monetáris szentiment szótárt mutatunk be. Az implementáció és a hozzá tartozó R forráskód a nyilvános https://doi.org/10.6084/m9.figshare.13526156.v1 linken. "],["klaszterelemzés-és-topic-modellezés.html", "8 Klaszterelemzés és topic modellezés", " 8 Klaszterelemzés és topic modellezés nyolcadik fejezet "],["szóbeágyazások.html", "9 Szóbeágyazások", " 9 Szóbeágyazások kilencedik fejezet "],["szövegösszehasonlítás.html", "10 Szövegösszehasonlítás", " 10 Szövegösszehasonlítás tizedik fejezet "],["természetes-nyelv-feldolgozás-nlp.html", "11 Természetes-nyelv feldolgozás (NLP)", " 11 Természetes-nyelv feldolgozás (NLP) tizenegyedik fejezet "],["osztályozás-és-felügyelt-tanulás.html", "12 Osztályozás és felügyelt tanulás", " 12 Osztályozás és felügyelt tanulás tizenkeddik fejezet "],["függelék.html", "13 Függelék 13.1 Az R és az RStudio használata 13.2 Vizualizáció", " 13 Függelék 13.1 Az R és az RStudio használata Az R egy programozási nyelv, amely alkalmas statisztikai számítások elvégzésére és ezek eredményeinek grafikus megjelenítésére. Az R ingyenes, nyílt forráskódú szoftver, mely telepíthet mind Windows, mind Linux, mind MacOS operációs rendszerek alatt, az alábbi oldalról: https://cran.r-project.org/ Az RStudio az R integrált fejleszti környezete (integrated development environment, IDE), mely egy olyan felhasználóbarát felületet biztosít, ami egyszerbb és átláthatóbb munkát tesz lehetvé. Az RStudio az alábbi oldalról tölthet le: https://rstudio.com/products/rstudio/download/ A point and click\" szoftverekkel szemben az R használata során kódot kell írni, ami bizonyos programozási jártasságot feltételez, de a késbbiekben lehetvé teszi azt adott kutatási kérdéshez maximálisan illeszked kódok összeállítását, melyek segítségével az elemzések mások számára is megbízhatóan reprodukálhatóak lesznek. Ugyancsak az R használata mellett szól, hogy komoly fejleszti és felhasználói közösséggel rendelkezik, így a használat során felmerül problémákra általában gyorsan megoldást találhatunk. 13.1.1 Az RStudio kezdfelülete Az RStudio kezdfelülete négy panelbl, eszközsorból és menüsorból áll: Figure 13.1: RStudio felhasználói felület Az (1) editor ablak szolgál a kód beírására, futtatására és mentésére. A (2) console ablakban jelenik meg a lefuttatott kód és az eredmények. A jobb fels ablak (3) environment fülén láthatóak a memóriában tárolt adatállományok, változók és felhasználói függvények. A history fül mutatja a korábban lefuttatott utasításokat. A jobb alsó ablak (4) files fülén az aktuális munkakönyvtárban lev mappákat és fájlok találjuk, míg a plot fülön az elemzéseink során elkészített ábrák jelennek meg. A packages fülön frissíthetjük a meglév r csomagokat és telepíthetünk újakat. A help fülön a különböz függvények, parancsok leírását, és használatát találjuk meg. A Tools -&gt; Global Options menüpont végezhetjük el az RStudio testreszabását. Így például beállíthatjuk az ablaktér elrendezését (Pane layout), vagy a színvilágot (Appearance), illetve azt hogy a kódok ne fussanak ki az ablakból (Code -&gt; Editing -&gt; Soft wrap R source files) 13.1.2 Projekt alapú munka Bár nem kötelez, de javasolt, hogy az RStudio-ban projekt alapon dolgozzunk, mivel így az összes  az adott projekttel kapcsolatos fájlt  egy mappában tárolhatjuk. Új projekt beállítását a File-&gt;New Project menüben tehetjük meg, ahol a saját gépünk egy könyvtárát kell kiválasztani, ahová az R scripteket, az adat- és elzményfájlokat menti. Ezenkívül a Tools-&gt;Global Options-&gt;General menüpont alatt le kell tiltani a Restore most recently opened project at startup és a Restore .RData ino workspace at startup beállítást, valamint Save workspace to .RData on exit értékre be kell állítani a Never értéket. Figure 13.2: RStudio projekt beállítások A szükséges beállítások után a File -&gt; New Project menüben hozhatjuk létre a projektet. Itt arra is lehetségünk van, hogy kiválasszuk, hogy a projektünket egy teljesen új könyvtárba, vagy egy meglévbe kívánjuk menteni, esetleg egy meglév projekt új verzióját szeretnénk létrehozni. Ha sikeresen létrehoztuk a projektet, az RStudio jobb fels sarkában látnunk kell annak nevét. 13.1.3 Scriptek szerkesztése, függvények használata Új script a File -&gt; New -&gt; File -&gt; R Script menüpontban hozható létre, mentésére a File-&gt;Save menüpontban egy korábbi script megnyitására File -&gt; Open menüpontban van lehetségünk. Script bármilyen szövegszerkesztvel írható és beilleszthet az editor ablakba. A scripteket érdemes magyarázatokkal (kommentekkel) ellátni, hogy a késbbiekben pontosan követhet legyen, hogy melyik parancs segítségével pontosan milyen lépéseket hajtottunk végre. A magyarázatokat vagy más néven kommenteket kettskereszt (#) karakterrel vezetjük be. A scriptbeli utasítások az azokat tartalmazó sorokra állva vagy több sort kijelölve a Run feliratra kattintva vagy a Ctrl+Enter billentyparanccsal futtathatók le. A lefuttatott parancsok és azok eredményei ezután a bal alsó sarokban lév console ablakban jelennek meg és ugyanitt kapunk hibaüzenetet is, ha valamilyen hibát vétettünk a scriptben. A munkafolyamat során létrehozott állományok (ábrák, fájlok) ebbe az ún. munkakönyvtárba (working directory) mentdnek. Az aktuális munkakönyvtár neve, elérési útja a getwd() utasítással jeleníthet meg. A könyvtárban található állományok listázására a list.files() utasítással van lehetségünk. Ha a korábbiaktól eltér munkakönyvtárat akarunk megadni, azt a setwd() függvénnyel tehetjük meg, ahol a ()-ben az adott mappa elérési útját kell megadnunk. Az elérési útban a meghajtó azonosítóját, majd a mappák, almappák nevét vagy egy normál irányú perjel (/), vagy két fordított perjel (\\\\) választja el, mivel az elérési út karakterlánc, ezért azt idézjelek vagy aposztrófok közé kell tennünk. Az aktuális munkakönyvtárba beléphetünk a jobb alsó ablak file lapján a More -&gt; Go To Working Directory segítségével. Ugyanitt a Set Working Directory-val munkakönyvtárnak állíthatjuk be az a mappát, amelyben épp benne vagyunk. Figure 13.3: Working directory beállítások A munkafolyamat befejezésére a q() vagy quit() függvényel van lehetségünk. A munkafolyamat során különböz objektumokat hozunk létre, melyek az RStudio jobb fels ablakának environment fülén jelennek meg, a mentett objektumokat a fent látható sepr ikonra kattintva törölhetjük a memóriából. Az environment ablakra érdemes úgy gondolni hogy ott jelennek meg a memóriában tárolt értékek. Az R-ben objektumokkal dolgozunk, amik a teljesség igénye nélkül lehetnek egyszer szám vektortok, vagy akár komplex listák, illetve függvények, ábrák. Az RStudio jobb alsó ablakának plots fülén láthatjuk azon parancsok eredményét, melyek kimenete valamilyen ábra. A packages fülnél a már telepített és a letölthet kiegészít csomagokat jeleníthetjük meg. A help fülön a korábban említettek szerint a súgó érhet el. Az RStudio-ban használható billentyparancsok teljes listáját Alt+Shift+K billentykombinációval tekinthetjük meg. Néhány gyakrabban használt, hasznos billentyparancs: Ctrl+Enter: futtassa a kódot az aktuális sorban Ctrl+Alt+B: futtassa a kódot az elejétl az aktuális sorig Ctrl+Alt+E: futtassa a kódot az aktuális sortól a forrásfájl végéig Ctrl+D: törölje az aktuális sort Az R-ben beépített függvények (function) állnak rendelkezésünkre a számítások végrehajtására, emellett több csomag (package) is letölthet, amelyek különböz függvényeket tartalmaznak. A függvények a következképpen épülnek fel: függvénynév(paraméter). Például tartalom képernyre való kiíratását a print() függvénnyel tehetjük, amelynek gömböly zárójelekkel határolt részébe írhatjuk a megjelenítend szöveget. A citation() függvénnyel lekérdezhetjük az egyes beépített csomagokra való hivatkozást is: a citation(quanteda) függvény a quanteda csomag hivatkozását adja meg. Az R súgórendszere a help.start() utasítással indítható el. Egy adott függvényre vonatkozó súgórészlet a függvények neve elé kérdjel írásával, vagy a help() argumentumába a kérdéses függvény nevének beírásával jeleníthet meg (pl.: help(sum)). 13.1.4 R csomagok Az R-ben telepíthetk kiegészít csomagok (packages), amelyek alapértelmezetten el nem érhet algoritmusokat, függvényeket tartalmaznak. A csomagok saját dokumentációval rendelkeznek, amelyeket fel kell tüntetni a használatukkal készült publikációink hivatkozáslistájában. A csomagok telepítésre több lehetségünk is van: használhatjuk a menüsor Tools -&gt; Install Packages menüpontját, vagy a jobb alsó ablak Packages fül Install menüpontját, illetve az editor ablakban az install.packages() parancsot futtatva, ahol a ()-be a telepíteni kívánt csomag nevét kell beírnunk (pl.: install.packages(dplyr)). Figure 13.4: Packages fül 13.1.5 Objektumok tárolása, értékadás Az objektumok lehetnek például vektorok, mátrixok (matrix), tömbök (array), adat táblák (data frame). Értékadás nélkül az R csak megjeleníti a mveletek eredményét, de nem tárolja el azokat. Az eredmények eltárolásához azokat egy objektumba kell elmentenünk. Ehhez meg kell adnunk az objektum nevét majd az &lt;- után adjuk meg annak értékét: a &lt;- 12 + 3.Futtatás után az environments fülön megjelenik az a objektum, melynek értéke 15. Az objektumok elnevezésénél figyelnünk kell arra, hogy az R különbséget tesz a kis és nagybetk között, valamint, hogy az ugyanolyan nev objektumokat kérdés nélkül felülírja és ezt a felülírást nem lehet visszavonni. 13.1.6 Vektorok Az R-ben kétféle típusú vektort különböztetünk meg: egyedüli vektor (atomic vector) lista (list) Az egyedüli vektornak hat típusa van, logikai (logical), egész szám (integer), természetes szám (double), karakter (character), komplex szám (complex) és nyers adat (raw). A leggyakrabban valamilyen numerikus, logikai vagy karakter vektorral használjuk. Az egyedüli vektorok onnan kapták a nevüket hogy csak egy féle adattípust tudnak tárolni. A listák ezzel szemben gyakorlatilag bármit tudnak tárolni, akár több listát is egybeágyazhatunk. A vektorok és listák azok az építelemek amikbl felépülnek az R objektumaink. Több érték vagy azonos típusú objektum összefzését a c() függvénnyel végezhetjük el. A lenti példában három különböz objektumot kreálunk, egy numerikusat, egy karaktert és egy logikait. A karakter vektorban az elemeket idzjellel és vesszvel szeparáljuk. A logikai vektor csak TRUE, illetve FALSE értékeket tartalmazhat. numerikus &lt;- c(1, 2, 3, 4, 5) karakter &lt;- c(&quot;kutya&quot;, &quot;macska&quot;, &quot;ló&quot;) logikai &lt;- c(TRUE, TRUE, FALSE) A létrehozott vektorokkal különböz mveleteket végezhetünk el, például összeadhatjuk numerikus vektorainkat. Ebben az esetben az els vektor els eleme a második vektor els eleméhez adódik. c(1:4) + c(10, 20, 30, 40) #&gt; [1] 11 22 33 44 A karaktervektorokat összefzhetjük egymással. Itt egy új objektumot is létrehoztunk, a jobb fels ablakban, az environment fülön láthatjuk, hogy a létrejött karakter_kombinalt objektum egy négy elem (hosszúságú) karaktervektor (chr [1:4]), melynek elemei a \"kutya\",\"macska\",\"ló\",\"nyúl\". Az objektumként tárolt vektorok tartalmát a lefuttatva írathatjuk ki a console ablakba. Habár van print() függvény az R-ben, azt ilyenkor nem szükséges használni. karakter1 &lt;- c(&quot;kutya&quot;, &quot;macska&quot;, &quot;ló&quot;) karakter2 &lt;- c(&quot;nyúl&quot;) karakter_kombinalt &lt;- c(karakter1, karakter2) karakter_kombinalt #&gt; [1] &quot;kutya&quot; &quot;macska&quot; &quot;ló&quot; &quot;nyúl&quot; Ha egy vektorról szeretnénk megtudni, hogy milyen típusú azt a typeof() vagy a class() paranccsal tehetjük meg, ahol ()-ben az adott objektumként tárolt vektor nevét kell megadnunk: typeof(karakter1). A vektor hosszúságát (benne tárolt elemek száma vektorok esetén) a lenght() függvénnyel tudhatjuk meg. typeof(karakter1) #&gt; [1] &quot;character&quot; length(karakter1) #&gt; [1] 3 13.1.7 Faktorok A faktorok a kategórikus adatok tárolására szolgálnak. Faktor típusú változó a factor() függvénnyel hozható létre. A faktor szintjeit (igen, semleges, nem), a levels() függvénnyel kaphatjuk meg míg az adatok címkéit (tehát a kapott válaszok száma), a labels() paranccsal érhetjük el. survey_response &lt;- factor(c(&quot;igen&quot;, &quot;semleges&quot;, &quot;nem&quot;, &quot;semleges&quot;, &quot;nem&quot;, &quot;nem&quot;, &quot;igen&quot;), ordered = TRUE) levels(survey_response) #&gt; [1] &quot;igen&quot; &quot;nem&quot; &quot;semleges&quot; labels(survey_response) #&gt; [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; &quot;5&quot; &quot;6&quot; &quot;7&quot; 13.1.8 Data frame Az adat táblák (data frame) a statisztikai és adatelemzési folyamatok egyik leggyakrabban használt adattárolási formája. Amikor lehetséges akkor a hosszú formátumban használjuk (az R közösség a tidy jelzvel illeti), aholtéglalap alakú adatszerkezetek, ahol minden sor egy megfigyelés és minden oszlop egy változó [TIDY CITATION]. Egy data frame többféle típusú adatot tartalmazhat. A data frame-k különféle oszlopokból állhatnak, amelyek különféle típusú adatokat tartalmazhatnak, de egy oszlop csak egy típusú adatból állhat. A lent bemutatott data frame 7 megfigyelést és 4 féle változót tartalmaz (id, country, pop, continent). #&gt; id orszag nepesseg kontinens #&gt; 1 1 Thailand 68.7 Asia #&gt; 2 2 Norway 5.2 Europe #&gt; 3 3 North Korea 24.0 Asia #&gt; 4 4 Canada 47.8 North America #&gt; 5 5 Slovenia 2.0 Europe #&gt; 6 6 France 63.6 Europe #&gt; 7 7 Venezuela 31.6 South America A data frame-be rendezett adatokhoz különböz módon férhetünk hozzá, például a data frame nevének majd []-ben a kívánt sor megadásával, kiírathatjuk a console ablakba annak tetszleges sorát ás oszlopát: orszag_adatok[1, 1]. Az R több különböz módot kínál a data frame sorainak és oszlopainak eléréséhez. A [ általános használata: data_frame[sor, oszlop]. Egy másik megoldás a $ haszálata: data_frame$oszlop. orszag_adatok[1, 4] #&gt; [1] Asia #&gt; Levels: Asia Europe North America South America orszag_adatok$orszag #&gt; [1] &quot;Thailand&quot; &quot;Norway&quot; &quot;North Korea&quot; &quot;Canada&quot; &quot;Slovenia&quot; #&gt; [6] &quot;France&quot; &quot;Venezuela&quot; 13.2 Vizualizáció library(ggplot2) library(gapminder) Az elemzéseinkhez használt data frame adatainak alapján a ggplot2 csomag segítségével lehetségünk van különböz vizualizációk készítésére is. A ggplot2 használata során különböz témákat alkalmazhatunk, melyek részletes leírása megtalálható: https://ggplot2.tidyverse.org/reference/ggtheme.html Abban az esetben, ha nem választunk témát, a ggplot2 a következ ábrán is látható alaptémát használja. Ha például a szürke helyett fehér hátteret szeretnénk, alkalmazhatjuk a theme_minmal()parancsot. Szintén gyakran alkalmazott ábra alap a thema_bw(), ami az elztl az ábra keretezésében különbözik. Ha fehér alapon, de a beosztások vonalait feketén szeretnénk megjeleníteni, alkalmazhatjuk a theme_linedraw() függvényt, a theme_void() segítségével pedig egy fehér alapon, beosztásoktól mentes alapot kapunk, a theme_dark() pedig sötét hátteret eredményez. A theme_classic() segítségével az x és y tengelyt jeleníthetjük meg fehér alapon. Egy ábra készítésének alapja mindig a használni kívánt adatkészlet beolvasása, illetve az ábrázolni kiíván változtót vagy változók megadása. Ezt követi a megfelel alakzat kiválasztása, attól függen például, hogy eloszlást, változást, adatok közötti kapcsolatot, vagy elétéseket akarunk ábrázolni. A geom az a geometriai objektum, a mit a diagram az adatok megjelenítésére használ. Agglpot2 több mint 40 féle alakzat alkalmazására ad lehetséget, ezek közül néhány gyakoribbat mutatunk be az alábbiakban. Az alakzatokról részletes leírása található például az alábbi linken: https://r4ds.had.co.nz/data-visualisation.html A következkben a már korábban is használt gapminder adatok segítségével, személetetjük az adatok vizualizálásának alapjait. Elször egyszer alapbeállítások mellett egy histogram típusú vizualizációt készítünk. ggplot( data = gapminder, mapping = aes(x = gdpPercap) ) + geom_histogram() Lehetségünk van arra, hogy az alakzat színét megváltoztatássuk. A használható színek és színkódok megtalálhatóak a ggplot2 leírásában: https://ggplot2-book.org/scale-colour.html ggplot( data = gapminder, mapping = aes(x = gdpPercap) ) + geom_histogram(fill = &quot;yellow&quot;, colour = &quot;green&quot;) Meghatározhatjuk külön-külön a histogram x és y tengelyén ábrázolni kívánt adatokat és választhatjuk azok pontszer ábrázolását is. ggplot( data = gapminder, mapping = aes( x = gdpPercap, y = lifeExp ) ) + geom_point() Ahogy az elzekben, itt is megváltoztathatjuk az ábra színét. ggplot( data = gapminder, mapping = aes( x = gdpPercap, y = lifeExp ) ) + geom_point(colour = &quot;blue&quot;) Az fenti script kibvítésével az egyes kontinensek adatait különböz színnel ábrázolhatjuk, az x és y tengelyt elnevezhetjük, a histogramnak címet és alcímet adhatunk, illetve az adataink forrását is feltüntethetjük az alábbi módon: ggplot( data = gapminder, mapping = aes( x = gdpPercap, y = lifeExp, color = continent ) ) + geom_point() + labs( x = &quot;GDP per capita (log $)&quot;, y = &quot;Life expectancy&quot;, title = &quot;Connection between GDP and Life expectancy&quot;, subtitle = &quot;Points are country-years&quot;, caption = &quot;Source: Gapminder dataset&quot; ) Az ábrán található feliratok méretének, bettípusának és betszínének megválasztásra is lehetségünk van. ggplot( data = gapminder, mapping = aes( x = gdpPercap, y = lifeExp, color = continent ) ) + geom_point() + labs( x = &quot;GDP per capita (log $)&quot;, y = &quot;Life expectancy&quot;, title = &quot;Connection between GDP and Life expectancy&quot;, subtitle = &quot;Points are country-years&quot;, caption = &quot;Source: Gapminder dataset&quot; ) + theme(plot.title = element_text( size = 12, colour = &quot;red&quot; )) Készíthetünk oszlopdiagramot is, amit a ggplot2 diamonds adatkészletén személtetünk ggplot(data = diamonds) + geom_bar(mapping = aes(x = cut)) Itt is lehetségünk van arra, hogy a diagram színét megváltoztassuk. ggplot(data = diamonds) + geom_bar(mapping = aes(x = cut), fill = &quot;darkgreen&quot;) De arra is lehetségünk van, hogy az egyes oszlopok eltér színek legyenek. ggplot(data = diamonds) + geom_bar(mapping = aes(x = cut, fill = cut)) Arra is van lehetségünk, hogy egyszerre több változót is ábrázoljunk. ggplot(data = diamonds) + geom_bar(mapping = aes(x = cut, fill = clarity)) Arra ggplot2 segítségével arra is lehetségünk van, hogy csv-bl beolvasott adatainkat vizualizáljuk. plot_cap_1 &lt;- read.csv(&quot;data/plot_cap_1.csv&quot;, head = TRUE, sep = &quot;;&quot;) ggplot(plot_cap_1, aes(Year, fill = Subtopic)) + scale_x_discrete(limits = c(1957, 1958, 1959, 1960, 1961, 1962, 1963)) + geom_bar(position = &quot;dodge&quot;) + labs( x = NULL, y = NULL, title = &quot;A Magyar Közlönyben kihirdetett agrárpolitikai jogszabályok&quot;, subtitle = &quot;N=445&quot; ) + coord_flip() + # az ábra tipusa theme_minimal() + theme(plot.title = element_text(size = 12)) A csv-bl belolvasott adatainból kördiagramot is készíthetünk pie &lt;- read.csv(&quot;data/pie.csv&quot;, head = TRUE, sep = &quot;;&quot;) ggplot(pie, aes(x = &quot;&quot;, y = value, fill = Type)) + geom_bar(stat = &quot;identity&quot;, width = 1) + coord_polar(&quot;y&quot;, start = 0) + scale_fill_brewer(palette = &quot;GnBu&quot;) + labs( title = &quot;A Magyar Közlönyben megjelent jogszabályok típusai&quot;, subtitle = &quot;N = 445&quot; ) + theme_void() Grimmer, Justin, and Brandon M Stewart. 2013. Text as Data: The Promise and Pitfalls of Automatic Content Analysis Methods for Political Texts. Political Analysis 21 (3): 267297. Laver, Michael, and John Garry. 2000. Estimating Policy Positions from Political Texts. American Journal of Political Science, 619634. Loughran, Tim, and Bill McDonald. 2011. When Is a Liability Not a Liability? Textual Analysis, Dictionaries, and 10-Ks. The Journal of Finance 66 (1): 3565. Máté, Ákos, Miklós Sebk, and Tamás Barczikay. 2021. The Effect of Central Bank Communication on Sovereign Bond Yields: The Case of Hungary. Edited by Hiranya K. Nath. PLOS ONE 16 (2): e0245515. https://doi.org/10.1371/journal.pone.0245515. Silge, Julia, and David Robinson. 2017. Text Mining with r: A Tidy Approach. \" OReilly Media, Inc.\". Wickham, Hadley, and Garrett Grolemund. 2016. R for Data Science: Import, Tidy, Transform, Visualize, and Model Data. \" OReilly Media, Inc.\". Young, Lori, and Stuart Soroka. 2012. Affective News: The Automated Coding of Sentiment in Political Texts. Political Communication 29 (2): 205231. "]]
