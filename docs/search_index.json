[["index.html", "Szövegbányászat és mesterséges intelligencia R-ben 1 Bevezetés", " Szövegbányászat és mesterséges intelligencia R-ben Sebk Miklós, Ring Orsolya 1 Bevezetés Jelen kötet a Kvantitatív szövegelemzés és szövegbányászat a politikatudományban (LHarmattan, 2016) cím könyv folytatásaként és egyben kiegészítéseként a szövegbányászat és a mesterséges intelligencia társadalomtudományi alkalmazásának gyakorlatába nyújt bevezetést. A szövegek kvantitatív elemzése (quantitative text analysis  QTA) a nemzetközi társadalomtudomány egyik leggyorsabban fejld irányzata. A szövegek és más minségi adatok (filmek, képek) elemzése annyiban különbözik a mennyiségi (kvantitatív) adatokétól, hogy nyers formájukban még nem alkalmasak arra, hogy statisztikai, illetve ökonometriai elemzés alá vessük ket, s így további módszertani problémákat vetnek fel, melyek speciális tárgyalása szükséges. A tervezett kötetben bemutatott példák többsége a politikatudományhoz kapcsolódik, de más alkalmazási területekre is kitér. Míg az elz kötet az egyes kódolási eljárásokat, illetve ezek kutatás-módszertani elnyeit és hátrányait ismertette, itt a társadalomtudományi elemzésének során használható kvantitatív szövegelemzés legfontosabb gyakorlati feladatait vesszük sorra. A kézirat a magyar tankönyvpiacon az elsnek számít a tekintetben, hogy a társadalomtudományban használatos kvantitatív szövegelemzési eljárásokat részletesen, lépésrl-lépésre ismerteti, kezdve a megfelel korpusz kialakításához szükséges ismeretektl, a különböz szövegbányászati módszerek (szózsák, dokumentum-kifejezés mátrix, a névelem-felismerés, az osztályozás, illetve a csoportosítás feladataira), illetve az egyszerbb szövegösszehasonlítási-feladatok áttekintésén át, egészen a felügyelt és felügyelet nélküli gépi tanulásig, a politikatudományi vizsgálatok során leggyakrabban használatos R programnyelven készült programok segítségével. Az olvasó a két kötet együttes használatával olyan ismeretek birtokába kerül, melyek révén képes lesz alkalmazni a kvantitatív szövegelemzés és szövegbányászat legalapvetbb eljárásait saját kutatására. Deduktív vagy induktív felfedez logikája fényében dönthet az adatelemzés módjáról, és a felkínált menübl kiválaszthatja a kutatási tervéhez legjobban illeszked megoldásokat. A kötetet végigkísér konkrét példák segítségével pedig akár reprodukálhatja is ezen eljárásokat saját kutatásában. Mindezt a kötet függelékében helyet kapó R-scriptek részletes leírása is segíti majd. A kötet két f célcsoportjaként így a társadalomtudományi kutatói és felsoktatási közösséget határozzuk meg, valamint rögzítjük, hogy a kvantitatív szövegelemzés területén belül elsdlegesen a dokumentum- és tartalomelemzési módszertanhoz kapcsolódunk. A könyvben ugyancsak helyet kap a fontosabb fogalmak magyar és angol nyelv szószedete, valamint a további olvasásra ajánlott szakirodalom szerepeltetése. Az oktatásban való közvetlen alkalmazást segíthetik továbbá a fejezetek végén megadott vizsgakérdések, illetve a kötet honlapján (qta.tk.mta.hu) szerepl további információk: gyakorlófeladatok (megoldásokkal), az egyes feladatokra alkalmazható scriptek és kereskedelmi programok bemutatása, a témával kapcsolatos prezentációk és további ajánlott irodalmak. "],["a-kvantitatív-szövegelemzés-és-szövegbányászat-alapfogalmai.html", "2 A kvantitatív szövegelemzés és szövegbányászat alapfogalmai", " 2 A kvantitatív szövegelemzés és szövegbányászat alapfogalmai elso fejezet "],["az-adatkezelés-r-ben.html", "3 Az adatkezelés R-ben 3.1 Adatok importálása és exportálása 3.2 Adatok exportálása 3.3 A pipe operátor 3.4 Muveletek a date framekkel 3.5 Munka karakter vektorokkal4", " 3 Az adatkezelés R-ben 3.1 Adatok importálása és exportálása Az adatok importálására az R alapfüggvénye mellett több package is megoldást kínál. Ezek közül a könyv írásakor a legnépszerbbek a readr és a rio csomagok. Az egyszerség kedvéért mi az alap read.csv() függvényt fogjuk használni. Amennyiben kihasználjuk az RStudio projekt opcióját (lásd a Függelékben) akkor elegend csak az elérni kívánt adatok relativ elérési útját megadni (relative path). Ideális esetben az adataink egy csv fileban vannak (comma separated values), ahol az egyes értékeket vesszk (vagy egyéb speciális karakter) választják el. Ez esetben a read.csv függvényt használjuk. A beolvasásnál egybl el is tároljuk az adatokat egy objektumban. A sep = opcióval tudjuk a szeparátor karaktert beállítani, mert elfordulhat hogy vessz helyett pontosvessz tagolja az adatainkat. df &lt;- read.csv(&quot;data/adatfile.csv&quot;, sep = &quot;,&quot;) Az R képes linkrl letölteni fileokat, elég megadnunk egy mköd elérési útvonalat. placeholder link, cserelni majd mukodore df_online &lt;- read.csv(&quot;https://www.qta.tk.mta.hu/adatok/adatfile.csv&quot;) Az R package ökoszisztémája kellen változatos ahhoz, hogy gyakorlatilag bármilyen inputtal meg tudjon bírkózni. Az Excel fileokat a readxl csomagot használva tudjuk betölteni (a csomagok installálásával kapcsolatban lásd a Függeléket), a read_excel()-t használva. A leggyakoribb statisztikai programok formátumait pedig a haven csomag tudja kezelni (például Stata, Spss, SAS). A szintaxis itt is hasonló: read_stata, read_spss, read_sas. 3.1.1 Szöveges dokumentumok importálása A nagy mennyiség szöveges dokumentum (a legyakrabban elforduló kiterjesztések: .txt, .doc, .pdf, .json, .csv, .xml, .rtf, .odt) betöltésére a legalkalmasabb a readtext package. Az alábbi példa azt mutatja be, hogy hogyan tudunk beolvasni egy adott mappából az összes .txt kiterjesztés file-t, anélkül hogy bármilyen loop-ot kellene írnunk, vagy egyenként megadni a file-ok neveit. A * karakter az azt jelenti ebben a környezetben, hogy bármilyen fájl, ami .txt-re végzdik. Amennyiben a fájlok nevei tartalmaznak valamilyen meta adatot tartalmaznak, akkor ezt be tudjuk allítani a betöltés során. Ilyen meta adat lehet például egy parlamenti felszólalásnál a felszólaló neve és a beszéd ideje és párttagsága (például: kovacsjanos_1994_fkgp.txt). df_text &lt;- readtext( &quot;data/*.txt&quot;, docvarsfrom = &quot;filenames&quot;, dvsep = &quot;_&quot;, docvarnames = c(&quot;nev&quot;, &quot;ev&quot;, &quot;part&quot;) ) 3.2 Adatok exportálása Az adatainkat R-bl a write.csv()-vel exportálhatjuk a kívánt helyre, .csv formátumban. Az R rendelkezik saját, .Rds és .Rda kiterjesztés, tömörített fájlformátummal. Mivel ezeket csak az R-ben nyithatjuk meg, érdemes a köztes, hosszadalmas számítást igényl lépések elmentésére használni, a saveRDS() és a save() parancsokkal. Az openxlsx csomaggal .xls és .xlsx Excel formátumokba is tudunk exportálni, hogyha szükséges. 3.3 A pipe operátor Az úgynevezett pipe operátor alapjaiban határozta meg a modern R fejldését és a népszer package ökoszisztéma, a tidyverse, egyik alapköve. Úgy gondoljuk, hogy a tidyverse és a pipe egyszerbbé teszi elsajátítani az R használatát, ezért mi is erre helyezzük a hangsúlyt.1 Vizuálisan a pipe operátor így néz ki: %&gt;% és arra szolgál hogy a kódban több egymáshoz kapcsolódó mveletet egybefzznk.2 Technikailag a pipe a bal oldali elemet adja meg a jobb oldali függvény els argumentumának. A lenti példa ugyanazt a folyamatot írja le, az alap R (base R) illetve a pipe használatával.3 Miközben a kódot olvassuk érdemes a pipe-ot és aztán-nak fordítani. reggeli(oltozkodes(felkeles(ebredes(en, idopont = &quot;8:00&quot;), oldal = &quot;jobb&quot;), nadrag = TRUE, ing = TRUE)) en %&gt;% ebredes(idopont = &quot;8:00&quot;) %&gt;% felkeles(oldal = &quot;jobb&quot;) %&gt;% oltozkodes(nadrag = TRUE, ing = TRUE) %&gt;% reggeli() A fenti példa is jól mutatja, hogy a pipe a bal oldali elemet fogja a jobb oldali függvény els elemének berakni. A fejezet további részeiben még bven fogunk gyakorlati példát találni a használatára. A fejezetben bemutatott példák az alkalmazásoknak csak egy relatíve szk körét mutatják be, ezért érdemes átolvasni a csomagokhoz tartozó dokumentációt, illetve ha van, akkor a mködést demonstráló bemutató oldalakat is. 3.4 Muveletek a date framekkel A data frame az egyik leghasznosabb és leggyakrabban használt adat tárolási mód az R-ben (a részletesebb leírás a Függelékben található) és ebben az alfejezetben azt mutatjuk be a dplyr és gapminder csomagok segíségével, hogy hogyan lehet hatékonyan dolgozni velük. A dplyr az egyik legnépszerbb R csomag, a tidyverse része. A gapminder csomag pedig a példa adatbázisunkat tartalmazza, amiben a világ országainak különböz gazdasági és társadalmi mutatói vannak. library(dplyr) library(gapminder) 3.4.1 Megfigyelések szrése: filter() A sorok (megfigyelések) szréséhez a dplyr csomag filter() parancsát használva lehetségünk van arra hogy egy vagy több kritérium alapján szkítsük az adatbázisunkat. A lenti példában azokat megfigyeléseket tartjuk meg, ahol az év 1962 és a várható élettartam nagyobb mint 72 év. gapminder %&gt;% filter(year == 1962, lifeExp &gt; 72) ## # A tibble: 5 x 6 ## country continent year lifeExp pop gdpPercap ## &lt;fct&gt; &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; ## 1 Denmark Europe 1962 72.4 4646899 13583. ## 2 Iceland Europe 1962 73.7 182053 10350. ## 3 Netherlands Europe 1962 73.2 11805689 12791. ## 4 Norway Europe 1962 73.5 3638919 13450. ## 5 Sweden Europe 1962 73.4 7561588 12329. De ugyanígy leválogathatjuk a data frame-bl az adatokat akkor is hogyha egy karakter változó alapján szeretnénk szrni. gapminder %&gt;% filter(country == &quot;Sweden&quot;, year &gt; 1990) ## # A tibble: 4 x 6 ## country continent year lifeExp pop gdpPercap ## &lt;fct&gt; &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; ## 1 Sweden Europe 1992 78.2 8718867 23880. ## 2 Sweden Europe 1997 79.4 8897619 25267. ## 3 Sweden Europe 2002 80.0 8954175 29342. ## 4 Sweden Europe 2007 80.9 9031088 33860. Itt tehát a data frame azon sorait szeretnénk látni, ahol az ország megegyezik a Sweden\" karakterlánccal az év pedig nagyobb, mint 1990. 3.4.2 Változók kiválogatása: select() A select() függvény segítségével válogathatunk oszlopokat a data frame-bl. A változók kiválasztására több megoldás is van. A dplyr csomag tartalmaz apróbb kisegít függvényeket, amik megkönnyítik a nagy adatbázisok esetén a változók kiválogatását a nevük alapján. Ezek a függvények a contains(), starts_with(), ends_with(), matches() és beszédesen arra szolgálnak hogy bizonyos nev változókat ne kelljen egyenként felsorolni. A select()-en belüli változó sorrend egyben az eredmény data frame változó sorrendjet is megadja. A negatív kiválasztás is lehetséges, ebben az esetben egy - kell tennünk a nemkívánt változó(k) elé (pl.: select(df, year, country, -continent). gapminder %&gt;% select(contains(&quot;ea&quot;), starts_with(&quot;co&quot;), pop) ## # A tibble: 1,704 x 4 ## year country continent pop ## &lt;int&gt; &lt;fct&gt; &lt;fct&gt; &lt;int&gt; ## 1 1952 Afghanistan Asia 8425333 ## 2 1957 Afghanistan Asia 9240934 ## 3 1962 Afghanistan Asia 10267083 ## 4 1967 Afghanistan Asia 11537966 ## 5 1972 Afghanistan Asia 13079460 ## 6 1977 Afghanistan Asia 14880372 ## 7 1982 Afghanistan Asia 12881816 ## 8 1987 Afghanistan Asia 13867957 ## 9 1992 Afghanistan Asia 16317921 ## 10 1997 Afghanistan Asia 22227415 ## # ... with 1,694 more rows 3.4.3 Új változók létrehozása: mutate() Az elemzési munkafolyamat elkerülhetetlen része hogy új változókat hozzunk létre, vagy a meglévket módosítsuk. Ezt a mutate()-el tehetjuk meg, ahol a szintaxis a következ: mutate(data frame, uj valtozo = ertekek). Példaként kiszámoljuk a Svéd GDP-t (milliárd dollárban) 1992-tl kezdve. A mutate() alkalmazásával részletesebben is foglalkozunk a szövegek elkészítésével foglalkozó fejezetben. gapminder %&gt;% filter(country == &quot;Sweden&quot;, year &gt;= 1992) %&gt;% mutate(gdp = (gdpPercap * pop) / 10^9) ## # A tibble: 4 x 7 ## country continent year lifeExp pop gdpPercap gdp ## &lt;fct&gt; &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Sweden Europe 1992 78.2 8718867 23880. 208. ## 2 Sweden Europe 1997 79.4 8897619 25267. 225. ## 3 Sweden Europe 2002 80.0 8954175 29342. 263. ## 4 Sweden Europe 2007 80.9 9031088 33860. 306. 3.4.4 Csoportonkénti statisztikák: group_by() és summarize() Az adataink részletesebb és alaposabb megismerésében segítenek a különböz szint leíró statisztikai adatok. A szintek megadására a group_by() használható, a csoportokon belüli számításokhoz pedig a summarize(). A lenti példa azt illusztrálja, hogyha kontinensenként csoportosítjuk a gapminder data framet, akkor a summarise() használatával megkaphatjuk a megfigyelések számát, illetve az átlagos per capita GDP-t. A summarise() a mutate() közeli rokona, hasonló szintaxissal és logikával használható. Ezt a függvény párost fogjuk majd használni a szöveges adataink leíró statisztikáinál is a 4. fejezetben. gapminder %&gt;% group_by(continent) %&gt;% summarise(megfigyelesek = n(), atlag_gdp = mean(gdpPercap)) ## `summarise()` ungrouping output (override with `.groups` argument) ## # A tibble: 5 x 3 ## continent megfigyelesek atlag_gdp ## &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; ## 1 Africa 624 2194. ## 2 Americas 300 7136. ## 3 Asia 396 7902. ## 4 Europe 360 14469. ## 5 Oceania 24 18622. 3.5 Munka karakter vektorokkal4 A szöveges adatokkal (karakter stringekkel) való munka elkerülhetetlen velejárója hogy a felesleges szövegelemeket, karaktereket el kell távolítanunk ahhoz hogy az elemzésünk hatásfoka javuljon (errl részletesebben a 3. fejezetben lesz szó). Erre a célra a stringr csomagot fogjuk használni, kombinálva a korábban bemutatott mutate()-el. A stringr függvények az str_ eltaggal kezddnek és eléggé beszédes nevekkel rendelkeznek. Egy gyakran elforduló probléma, hogy extra szóközök maradnak a szövegben, vagy bizonyos szavakról, karakterkombinációkról tudjuk hogy nem kellenek az elemzésünkhoz. Ebben az esetben egy vagy több regular expression (regex) használatával tudjuk pontosan kijelölni hogy a karakter sornak melyik részét akarjuk módosítani. A legegyszerbb formája a regexeknek, hogyha pontosan tudjuk milyen szöveget akarunk megtalálni. A kísérletezésre az str_view()-t használjuk, ami megjeleníti hogy a megadott regex mintánk pontosan mit jelöl. library(stringr) szoveg &lt;- c(&#39;gitar&#39;, &#39;ukulele&#39;, &#39;nagybogo&#39;) str_view(szoveg, pattern = &quot;ar&quot;) Az anchor-okkal azt lehet megadni, hogy a karakter string elején vagy végén szeretnénk egyezést találni. A string eleji anchor a ^, a string végi pedig a $. str_view(&quot;Dr. Doktor Dr.&quot;, pattern = &quot;^Dr.&quot;) str_view(&quot;Dr. Doktor Dr.&quot;, pattern = &quot;Dr.$&quot;) Egy másik jellemz probléma, hogy olyan speciális karaktert akarunk leírni a regex kifejezésünkkel, ami amúgy a regex szintaxisban használt. Ilyen eset például a ., ami mint írásjel sokszor csak zaj, ám a regex kotextusban a bármilyen karakter megfelelje. str_view(&quot;Dr. Doktor Dr.&quot;, pattern = &quot;.k.&quot;) Ahhoz hogy magát az írásjelet jelöljük, a \\\\ -t kell elé rakni. str_view(&quot;Dr. Doktor Dr.&quot;, pattern = &quot;\\\\.&quot;) Néhány hasznos regex kifejezés: [:digit:] - számok (123) [:alpha:] - betk (abc ABC) [:lower:] - kisbetk (abc) [:upper:] - nagybetk (ABC) [:alnum:] - betk és számok (123 abc ABC) [:punct:] - központozás (.!?\\(){}) [:graph:] - betk, számok és központozás (123 abc ABC .!?\\(){}) [:space:] - szóköz ( ) [:blank:] - szóköz és tabulálás * - bármi A tidyverse megközelítés miatt a kötetben szerepl R kód követi a The tidyverse style guide dokumentációt (https://style.tidyverse.org/) Az RStudio-ban a pipe operátor billenty kombinációja a Ctrl + Shift + M Köszönjük Andrew Heissnek a kitn példát. A könyv terjedelme miatt ezt a témát itt csak bemutatni tudjuk, de minden részletre kiterjeden nem tudunk elmélyülni benne. Kíváló online anyagok találhatóak az RStudio GitHub tárhelyén (https://github.com/rstudio/cheatsheets/raw/master/strings.pdf), illetve @wickham2016r 14. fejezetében. "],["leíró-statisztika-szózsák-és-szóeloszlások.html", "4 Leíró statisztika: szózsák és szóeloszlások", " 4 Leíró statisztika: szózsák és szóeloszlások negyedik fejezet "],["a-szövegek-reprezentálása-a-vektortérben.html", "5 A szövegek reprezentálása a vektortérben", " 5 A szövegek reprezentálása a vektortérben otodik fejezet "],["a-korpuszépítés-problémái-és-a-szövegel-készítés.html", "6 A korpuszépítés problémái és a szövegelkészítés", " 6 A korpuszépítés problémái és a szövegelkészítés hatodik fejezet "],["szótáralapú-elemzések-érzelem-elemzés.html", "7 Szótáralapú elemzések, érzelem-elemzés", " 7 Szótáralapú elemzések, érzelem-elemzés hetedik fejezet "],["klaszterelemzés-és-topic-modellezés.html", "8 Klaszterelemzés és topic modellezés", " 8 Klaszterelemzés és topic modellezés nyolcadik fejezet "],["szóbeágyazások.html", "9 Szóbeágyazások", " 9 Szóbeágyazások kilencedik fejezet "],["szövegösszehasonlítás.html", "10 Szövegösszehasonlítás", " 10 Szövegösszehasonlítás tizedik fejezet "],["természetes-nyelv-feldolgozás-nlp.html", "11 Természetes-nyelv feldolgozás (NLP)", " 11 Természetes-nyelv feldolgozás (NLP) tizenegyedik fejezet "],["osztályozás-és-felügyelt-tanulás.html", "12 Osztályozás és felügyelt tanulás", " 12 Osztályozás és felügyelt tanulás tizenkeddik fejezet "],["függelék.html", "13 Függelék 13.1 Az R és az RStudio használata 13.2 Vizualizáció", " 13 Függelék 13.1 Az R és az RStudio használata Az R egy programozási nyelv, amely alkalmas statisztikai számítások elvégzésére és ezek eredményeinek grafikus megjelenítésére. Az R ingyenes, nyílt forráskódú szoftver, mely telepíthet mind Windows, mind Linux, mind MacOS operációs rendszerek alatt, az alábbi oldalról: https://cran.r-project.org/ Az RStudio az R integrált fejleszti környezete (integrated development environment, IDE), mely egy olyan felhasználóbarát felületet biztosít, ami egyszerbb és átláthatóbb munkát tesz lehetvé. Az RStudio az alábbi oldalról tölthet le: https://rstudio.com/products/rstudio/download/ A point and click\" szoftverekkel szemben az R használata során kódot kell írni, ami bizonyos programozási jártasságot feltételez, de a késbbiekben lehetvé teszi azt adott kutatási kérdéshez maximálisan illeszked kódok összeállítását, melyek segítségével az elemzések mások számára is megbízhatóan reprodukálhatóak lesznek. Ugyancsak az R használata mellett szól, hogy komoly fejleszti és felhasználói közösséggel rendelkezik, így a használat során felmerül problémákra általában gyorsan megoldást találhatunk. 13.1.1 Az RStudio kezdfelülete Az RStudio kezdfelülete négy panelbl, eszközsorból és menüsorból áll: Figure 13.1: RStudio felhasználói felület Az (1) editor ablak szolgál a kód beírására, futtatására és mentésére. A (2) console ablakban jelenik meg a lefuttatott kód és az eredmények. A jobb fels ablak (3) environment fülén láthatóak a memóriában tárolt adatállományok, változók és felhasználói függvények. A history fül mutatja a korábban lefuttatott utasításokat. A jobb alsó ablak (4) files fülén az aktuális munkakönyvtárban lev mappákat és fájlok találjuk, míg a plot fülön az elemzéseink során elkészített ábrák jelennek meg. A packages fülön frissíthetjük a meglév r csomagokat és telepíthetünk újakat. A help fülön a különböz függvények, parancsok leírását, és használatát találjuk meg. A Tools -&gt; Global Options menüpont végezhetjük el az RStudio testreszabását. Így például beállíthatjuk az ablaktér elrendezését (Pane layout), vagy a színvilágot (Appearance), illetve azt hogy a kódok ne fussanak ki az ablakból (Code -&gt; Editing -&gt; Soft wrap R source files) 13.1.2 Projekt alapú munka Bár nem kötelez, de javasolt, hogy az RStudio-ban projekt alapon dolgozzunk, mivel így az összes  az adott projekttel kapcsolatos fájlt  egy mappában tárolhatjuk. Új projekt beállítását a File-&gt;New Project menüben tehetjük meg, ahol a saját gépünk egy könyvtárát kell kiválasztani, ahová az R scripteket, az adat- és elzményfájlokat menti. Ezenkívül a Tools-&gt;Global Options-&gt;General menüpont alatt le kell tiltani a Restore most recently opened project at startup és a Restore .RData ino workspace at startup beállítást, valamint Save workspace to .RData on exit értékre be kell állítani a Never értéket. Figure 13.2: RStudio projekt beállítások A szükséges beállítások után a File -&gt; New Project menüben hozhatjuk létre a projektet. Itt arra is lehetségünk van, hogy kiválasszuk, hogy a projektünket egy teljesen új könyvtárba, vagy egy meglévbe kívánjuk menteni, esetleg egy meglév projekt új verzióját szeretnénk létrehozni. Ha sikeresen létrehoztuk a projektet, az RStudio jobb fels sarkában látnunk kell annak nevét. 13.1.3 Scriptek szerkesztése, függvények használata Új script a File -&gt; New -&gt; File -&gt; R Script menüpontban hozható létre, mentésére a File-&gt;Save menüpontban egy korábbi script megnyitására File -&gt; Open menüpontban van lehetségünk. Script bármilyen szövegszerkesztvel írható és beilleszthet az editor ablakba. A scripteket érdemes magyarázatokkal (kommentekkel) ellátni, hogy a késbbiekben pontosan követhet legyen, hogy melyik parancs segítségével pontosan milyen lépéseket hajtottunk végre. A magyarázatokat vagy más néven kommenteket kettskereszt (#) karakterrel vezetjük be. A scriptbeli utasítások az azokat tartalmazó sorokra állva vagy több sort kijelölve a Run feliratra kattintva vagy a Ctrl+Enter billentyparanccsal futtathatók le. A lefuttatott parancsok és azok eredményei ezután a bal alsó sarokban lév console ablakban jelennek meg és ugyanitt kapunk hibaüzenetet is, ha valamilyen hibát vétettünk a scriptben. A munkafolyamat során létrehozott állományok (ábrák, fájlok) ebbe az ún. munkakönyvtárba (working directory) mentdnek. Az aktuális munkakönyvtár neve, elérési útja a getwd() utasítással jeleníthet meg. A könyvtárban található állományok listázására a list.files() utasítással van lehetségünk. Ha a korábbiaktól eltér munkakönyvtárat akarunk megadni, azt a setwd() függvénnyel tehetjük meg, ahol a ()-ben az adott mappa elérési útját kell megadnunk. Az elérési útban a meghajtó azonosítóját, majd a mappák, almappák nevét vagy egy normál irányú perjel (/), vagy két fordított perjel (\\\\) választja el, mivel az elérési út karakterlánc, ezért azt idézjelek vagy aposztrófok közé kell tennünk. Az aktuális munkakönyvtárba beléphetünk a jobb alsó ablak file lapján a More -&gt; Go To Working Directory segítségével. Ugyanitt a Set Working Directory-val munkakönyvtárnak állíthatjuk be az a mappát, amelyben épp benne vagyunk. Figure 13.3: Working directory beállítások A munkafolyamat befejezésére a q() vagy quit() függvényel van lehetségünk. A munkafolyamat során különböz objektumokat hozunk létre, melyek az RStudio jobb fels ablakának environment fülén jelennek meg, a mentett objektumokat a fent látható sepr ikonra kattintva törölhetjük a memóriából. Az environment ablakra érdemes úgy gondolni hogy ott jelennek meg a memóriában tárolt értékek. Az R-ben objektumokkal dolgozunk, amik a teljesség igénye nélkül lehetnek egyszer szám vektortok, vagy akár komplex listák, illetve függvények, ábrák. Az RStudio jobb alsó ablakának plots fülén láthatjuk azon parancsok eredményét, melyek kimenete valamilyen ábra. A packages fülnél a már telepített és a letölthet kiegészít csomagokat jeleníthetjük meg. A help fülön a korábban említettek szerint a súgó érhet el. Az RStudio-ban használható billentyparancsok teljes listáját Alt+Shift+K billentykombinációval tekinthetjük meg. Néhány gyakrabban használt, hasznos billentyparancs: Ctrl+Enter: futtassa a kódot az aktuális sorban Ctrl+Alt+B: futtassa a kódot az elejétl az aktuális sorig Ctrl+Alt+E: futtassa a kódot az aktuális sortól a forrásfájl végéig Ctrl+D: törölje az aktuális sort Az R-ben beépített függvények (function) állnak rendelkezésünkre a számítások végrehajtására, emellett több csomag (package) is letölthet, amelyek különböz függvényeket tartalmaznak. A függvények a következképpen épülnek fel: függvénynév(paraméter). Például tartalom képernyre való kiíratását a print() függvénnyel tehetjük, amelynek gömböly zárójelekkel határolt részébe írhatjuk a megjelenítend szöveget. A citation() függvénnyel lekérdezhetjük az egyes beépített csomagokra való hivatkozást is: a citation(quanteda) függvény a quanteda csomag hivatkozását adja meg. Az R súgórendszere a help.start() utasítással indítható el. Egy adott függvényre vonatkozó súgórészlet a függvények neve elé kérdjel írásával, vagy a help() argumentumába a kérdéses függvény nevének beírásával jeleníthet meg (pl.: help(sum)). 13.1.4 R csomagok Az R-ben telepíthetk kiegészít csomagok (packages), amelyek alapértelmezetten el nem érhet algoritmusokat, függvényeket tartalmaznak. A csomagok saját dokumentációval rendelkeznek, amelyeket fel kell tüntetni a használatukkal készült publikációink hivatkozáslistájában. A csomagok telepítésre több lehetségünk is van: használhatjuk a menüsor Tools -&gt; Install Packages menüpontját, vagy a jobb alsó ablak Packages fül Install menüpontját, illetve az editor ablakban az install.packages() parancsot futtatva, ahol a ()-be a telepíteni kívánt csomag nevét kell beírnunk (pl.: install.packages(dplyr)). Figure 13.4: Packages fül 13.1.5 Objektumok tárolása, értékadás Az objektumok lehetnek például vektorok, mátrixok (matrix), tömbök (array), adat táblák (data frame). Értékadás nélkül az R csak megjeleníti a mveletek eredményét, de nem tárolja el azokat. Az eredmények eltárolásához azokat egy objektumba kell elmentenünk. Ehhez meg kell adnunk az objektum nevét majd az &lt;- után adjuk meg annak értékét: a &lt;- 12 + 3.Futtatás után az environments fülön megjelenik az a objektum, melynek értéke 15. Az objektumok elnevezésénél figyelnünk kell arra, hogy az R különbséget tesz a kis és nagybetk között, valamint, hogy az ugyanolyan nev objektumokat kérdés nélkül felülírja és ezt a felülírást nem lehet visszavonni. 13.1.6 Vektorok Az R-ben kétféle típusú vektort különböztetünk meg: egyedüli vektor (atomic vector) lista (list) Az egyedüli vektornak hat típusa van, logikai (logical), egész szám (integer), természetes szám (double), karakter (character), komplex szám (complex) és nyers adat (raw). A leggyakrabban valamilyen numerikus, logikai vagy karakter vektorral használjuk. Az egyedüli vektorok onnan kapták a nevüket hogy csak egy féle adattípust tudnak tárolni. A listák ezzel szemben gyakorlatilag bármit tudnak tárolni, akár több listát is egybeágyazhatunk. A vektorok és listák azok az építelemek amikbl felépülnek az R objektumaink. Több érték vagy azonos típusú objektum összefzését a c() függvénnyel végezhetjük el. A lenti példában három különböz objektumot kreálunk, egy numerikusat, egy karaktert és egy logikait. A karakter vektorban az elemeket idzjellel és vesszvel szeparáljuk. A logikai vektor csak TRUE, illetve FALSE értékeket tartalmazhat. numerikus &lt;- c(1,2,3,4,5) karakter &lt;- c(&quot;kutya&quot;,&quot;macska&quot;,&quot;ló&quot;) logikai &lt;- c(TRUE, TRUE, FALSE) A létrehozott vektorokkal különböz mveleteket végezhetünk el, például összeadhatjuk numerikus vektorainkat. Ebben az esetben az els vektor els eleme a második vektor els eleméhez adódik. c(1:4) + c(10,20,30,40) ## [1] 11 22 33 44 A karaktervektorokat összefzhetjük egymással. Itt egy új objektumot is létrehoztunk, a jobb fels ablakban, az environment fülön láthatjuk, hogy a létrejött karakter_kombinalt objektum egy négy elem (hosszúságú) karaktervektor (chr [1:4]), melynek elemei a \"kutya\",\"macska\",\"ló\",\"nyúl\". Az objektumként tárolt vektorok tartalmát a lefuttatva írathatjuk ki a console ablakba. Habár van print() függvény az R-ben, azt ilyenkor nem szükséges használni. karakter1 &lt;- c(&quot;kutya&quot;,&quot;macska&quot;,&quot;ló&quot;) karakter2 &lt;-c(&quot;nyúl&quot;) karakter_kombinalt &lt;-c(karakter1, karakter2) karakter_kombinalt ## [1] &quot;kutya&quot; &quot;macska&quot; &quot;ló&quot; &quot;nyúl&quot; Ha egy vektorról szeretnénk megtudni, hogy milyen típusú azt a typeof() vagy a class() paranccsal tehetjük meg, ahol ()-ben az adott objektumként tárolt vektor nevét kell megadnunk: typeof(karakter1). A vektor hosszúságát (benne tárolt elemek száma vektorok esetén) a lenght() függvénnyel tudhatjuk meg. typeof(karakter1) ## [1] &quot;character&quot; length(karakter1) ## [1] 3 13.1.7 Faktorok A faktorok a kategórikus adatok tárolására szolgálnak. Faktor típusú változó a factor() függvénnyel hozható létre. A faktor szintjeit (igen, semleges, nem), a levels() függvénnyel kaphatjuk meg míg az adatok címkéit (tehát a kapott válaszok száma), a labels() paranccsal érhetjük el. survey_response &lt;- factor(c(&quot;igen&quot;, &quot;semleges&quot;, &quot;nem&quot;, &quot;semleges&quot;, &quot;nem&quot;, &quot;nem&quot;, &quot;igen&quot;), ordered = TRUE) levels(survey_response) ## [1] &quot;igen&quot; &quot;nem&quot; &quot;semleges&quot; labels(survey_response) ## [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; &quot;5&quot; &quot;6&quot; &quot;7&quot; 13.1.8 Data frame Az adat táblák (data frame) a statisztikai és adatelemzési folyamatok egyik leggyakrabban használt adattárolási formája. Amikor lehetséges akkor a hosszú formátumban használjuk (az R közösség a tidy jelzvel illeti), aholtéglalap alakú adatszerkezetek, ahol minden sor egy megfigyelés és minden oszlop egy változó [TIDY CITATION]. Egy data frame többféle típusú adatot tartalmazhat. A data frame-k különféle oszlopokból állhatnak, amelyek különféle típusú adatokat tartalmazhatnak, de egy oszlop csak egy típusú adatból állhat. A lent bemutatott data frame 7 megfigyelést és 4 féle változót tartalmaz (id, country, pop, continent). ## id orszag nepesseg kontinens ## 1 1 Thailand 68.7 Asia ## 2 2 Norway 5.2 Europe ## 3 3 North Korea 24.0 Asia ## 4 4 Canada 47.8 North America ## 5 5 Slovenia 2.0 Europe ## 6 6 France 63.6 Europe ## 7 7 Venezuela 31.6 South America A data frame-be rendezett adatokhoz különböz módon férhetünk hozzá, például a data frame nevének majd []-ben a kívánt sor megadásával, kiírathatjuk a console ablakba annak tetszleges sorát ás oszlopát: orszag_adatok[1, 1]. Az R több különböz módot kínál a data frame sorainak és oszlopainak eléréséhez. A [ általános használata: data_frame[sor, oszlop]. Egy másik megoldás a $ haszálata: data_frame$oszlop. orszag_adatok[1, 4] ## [1] Asia ## Levels: Asia Europe North America South America orszag_adatok$orszag ## [1] &quot;Thailand&quot; &quot;Norway&quot; &quot;North Korea&quot; &quot;Canada&quot; &quot;Slovenia&quot; ## [6] &quot;France&quot; &quot;Venezuela&quot; 13.2 Vizualizáció library(ggplot2) library(gapminder) Az elemzéseinkhez használt data frame adatainak alapján a ggplot2 csomag segítségével lehetségünk van különböz vizualizációk készítésére is. A ggplot2 használata során különböz témákat alkalmazhatunk, melyek részletes leírása megtalálható: https://ggplot2.tidyverse.org/reference/ggtheme.html Abban az esetben, ha nem választunk témát, a ggplot2 a következ ábrán is látható alaptémát használja. Ha például a szürke helyett fehér hátteret szeretnénk, alkalmazhatjuk a theme_minmal()parancsot. Szintén gyakran alkalmazott ábra alap a thema_bw(), ami az elztl az ábra keretezésében különbözik. Ha fehér alapon, de a beosztások vonalait feketén szeretnénk megjeleníteni, alkalmazhatjuk a theme_linedraw() függvényt, a theme_void() segítségével pedig egy fehér alapon, beosztásoktól mentes alapot kapunk, a theme_dark() pedig sötét hátteret eredményez. A theme_classic() segítségével az x és y tengelyt jeleníthetjük meg fehér alapon. Egy ábra készítésének alapja mindig a használni kívánt adatkészlet beolvasása, illetve az ábrázolni kiíván változtót vagy változók megadása. Ezt követi a megfelel alakzat kiválasztása, attól függen például, hogy eloszlást, változást, adatok közötti kapcsolatot, vagy elétéseket akarunk ábrázolni. A geom az a geometriai objektum, a mit a diagram az adatok megjelenítésére használ. Agglpot2 több mint 40 féle alakzat alkalmazására ad lehetséget, ezek közül néhány gyakoribbat mutatunk be az alábbiakban. Az alakzatokról részletes leírása található például az alábbi linken: https://r4ds.had.co.nz/data-visualisation.html A következkben a már korábban is használt gapminder adatok segítségével, személetetjük az adatok vizualizálásának alapjait. Elször egyszer alapbeállítások mellett egy histogram típusú vizualizációt készítünk. ggplot( data = gapminder, mapping = aes(x = gdpPercap) ) + geom_histogram() Lehetségünk van arra, hogy az alakzat színét megváltoztatássuk. A használható színek és színkódok megtalálhatóak a ggplot2 leírásában: https://ggplot2-book.org/scale-colour.html ggplot( data = gapminder, mapping = aes(x = gdpPercap) ) + geom_histogram(fill = &quot;yellow&quot;, colour = &quot;green&quot;) Meghatározhatjuk külön-külön a histogram x és y tengelyén ábrázolni kívánt adatokat és választhatjuk azok pontszer ábrázolását is. ggplot( data = gapminder, mapping = aes( x = gdpPercap, y = lifeExp ) ) + geom_point() Ahogy az elzekben, itt is megváltoztathatjuk az ábra színét. ggplot( data = gapminder, mapping = aes( x = gdpPercap, y = lifeExp ) ) + geom_point(colour = &quot;blue&quot;) Az fenti script kibvítésével az egyes kontinensek adatait különböz színnel ábrázolhatjuk, az x és y tengelyt elnevezhetjük, a histogramnak címet és alcímet adhatunk, illetve az adataink forrását is feltüntethetjük az alábbi módon: ggplot( data = gapminder, mapping = aes( x = gdpPercap, y = lifeExp, color = continent ) ) + geom_point() + labs( x = &quot;GDP per capita (log $)&quot;, y = &quot;Life expectancy&quot;, title = &quot;Connection between GDP and Life expectancy&quot;, subtitle = &quot;Points are country-years&quot;, caption = &quot;Source: Gapminder dataset&quot; ) Az ábrán található feliratok méretének, bettípusának és betszínének megválasztásra is lehetségünk van. ggplot( data = gapminder, mapping = aes( x = gdpPercap, y = lifeExp, color = continent ) ) + geom_point() + labs( x = &quot;GDP per capita (log $)&quot;, y = &quot;Life expectancy&quot;, title = &quot;Connection between GDP and Life expectancy&quot;, subtitle = &quot;Points are country-years&quot;, caption = &quot;Source: Gapminder dataset&quot; ) + theme(plot.title = element_text( size = 12, colour = &quot;red&quot; )) Készíthetünk oszlopdiagramot is, amit a ggplot2 diamonds adatkészletén személtetünk ggplot(data = diamonds) + geom_bar(mapping = aes(x = cut)) Itt is lehetségünk van arra, hogy a diagram színét megváltoztassuk. ggplot(data = diamonds) + geom_bar(mapping = aes(x = cut), fill = &quot;darkgreen&quot;) De arra is lehetségünk van, hogy az egyes oszlopok eltér színek legyenek. ggplot(data = diamonds) + geom_bar(mapping = aes(x = cut, fill = cut)) Arra is van lehetségünk, hogy egyszerre több változót is ábrázoljunk. ggplot(data = diamonds) + geom_bar(mapping = aes(x = cut, fill = clarity)) Arra ggplot2 segítségével arra is lehetségünk van, hogy csv-bl beolvasott adatainkat vizualizáljuk. plot_cap_1 &lt;- read.csv(&quot;data/plot_cap_1.csv&quot;, head = TRUE, sep = &quot;;&quot;) ggplot(plot_cap_1, aes(Year, fill = Subtopic)) + scale_x_discrete(limits = c(1957, 1958, 1959, 1960, 1961, 1962, 1963)) + geom_bar(position = &quot;dodge&quot;) + labs( x = NULL, y = NULL, title = &quot;A Magyar Közlönyben kihirdetett agrárpolitikai jogszabályok&quot;, subtitle = &quot;N=445&quot; ) + coord_flip() + # az ábra tipusa theme_minimal() + theme(plot.title = element_text(size = 12)) A csv-bl belolvasott adatainból kördiagramot is készíthetünk pie &lt;- read.csv(&quot;data/pie.csv&quot;, head = TRUE, sep = &quot;;&quot;) ggplot(pie, aes(x = &quot;&quot;, y = value, fill = Type)) + geom_bar(stat = &quot;identity&quot;, width = 1) + coord_polar(&quot;y&quot;, start = 0) + scale_fill_brewer(palette = &quot;GnBu&quot;) + labs( title = &quot;A Magyar Közlönyben megjelent jogszabályok típusai&quot;, subtitle = &quot;N = 445&quot; ) + theme_void() "]]
